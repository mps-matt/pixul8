<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PixUl8: cv::cuda::BufferPool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PixUl8
   &#160;<span id="projectnumber">3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecv.html">cv</a></li><li class="navelem"><b>cuda</b></li><li class="navelem"><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html">BufferPool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcv_1_1cuda_1_1_buffer_pool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cv::cuda::BufferPool Class Reference<div class="ingroups"><a class="el" href="group__cuda.html">CUDA-accelerated Computer Vision</a> &raquo; <a class="el" href="group__cudacore.html">Core part</a> &raquo; <a class="el" href="group__cudacore__struct.html">Data Structures</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html" title="BufferPool for use with CUDA streams.">BufferPool</a> for use with CUDA streams.  
 <a href="classcv_1_1cuda_1_1_buffer_pool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_open_c_v_2opencv2_8framework_2_versions_2_a_2_headers_2core_2cuda_8hpp_source.html">cuda.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0f1e0a518847d41663e7344927515761"><td class="memItemLeft" align="right" valign="top"><a id="a0f1e0a518847d41663e7344927515761"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html#a0f1e0a518847d41663e7344927515761">BufferPool</a> (<a class="el" href="classcv_1_1cuda_1_1_stream.html">Stream</a> &amp;stream)</td></tr>
<tr class="memdesc:a0f1e0a518847d41663e7344927515761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html" title="BufferPool for use with CUDA streams.">BufferPool</a> for the given stream. <br /></td></tr>
<tr class="separator:a0f1e0a518847d41663e7344927515761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715fecc85a804935c8c5a6c4eb4f905e"><td class="memItemLeft" align="right" valign="top"><a id="a715fecc85a804935c8c5a6c4eb4f905e"></a>
<a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html">GpuMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html#a715fecc85a804935c8c5a6c4eb4f905e">getBuffer</a> (int rows, int cols, int type)</td></tr>
<tr class="memdesc:a715fecc85a804935c8c5a6c4eb4f905e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new <a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html" title="Base storage class for GPU memory with reference counting.">GpuMat</a> of given size and type. <br /></td></tr>
<tr class="separator:a715fecc85a804935c8c5a6c4eb4f905e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3555cf098c2ca2b9112f18393f6095e"><td class="memItemLeft" align="right" valign="top"><a id="ae3555cf098c2ca2b9112f18393f6095e"></a>
<a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html">GpuMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html#ae3555cf098c2ca2b9112f18393f6095e">getBuffer</a> (<a class="el" href="classcv_1_1_size__.html">Size</a> size, int type)</td></tr>
<tr class="memdesc:ae3555cf098c2ca2b9112f18393f6095e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new <a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html" title="Base storage class for GPU memory with reference counting.">GpuMat</a> of given size and type. <br /></td></tr>
<tr class="separator:ae3555cf098c2ca2b9112f18393f6095e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d639258399df2b804a88afa334b022b"><td class="memItemLeft" align="right" valign="top"><a id="a4d639258399df2b804a88afa334b022b"></a>
<a class="el" href="structcv_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classcv_1_1cuda_1_1_gpu_mat_1_1_allocator.html">GpuMat::Allocator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html#a4d639258399df2b804a88afa334b022b">getAllocator</a> () const</td></tr>
<tr class="memdesc:a4d639258399df2b804a88afa334b022b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the stream. <br /></td></tr>
<tr class="separator:a4d639258399df2b804a88afa334b022b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1e0a518847d41663e7344927515761"><td class="memItemLeft" align="right" valign="top"><a id="a0f1e0a518847d41663e7344927515761"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html#a0f1e0a518847d41663e7344927515761">BufferPool</a> (<a class="el" href="classcv_1_1cuda_1_1_stream.html">Stream</a> &amp;stream)</td></tr>
<tr class="memdesc:a0f1e0a518847d41663e7344927515761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html" title="BufferPool for use with CUDA streams.">BufferPool</a> for the given stream. <br /></td></tr>
<tr class="separator:a0f1e0a518847d41663e7344927515761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715fecc85a804935c8c5a6c4eb4f905e"><td class="memItemLeft" align="right" valign="top"><a id="a715fecc85a804935c8c5a6c4eb4f905e"></a>
<a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html">GpuMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html#a715fecc85a804935c8c5a6c4eb4f905e">getBuffer</a> (int rows, int cols, int type)</td></tr>
<tr class="memdesc:a715fecc85a804935c8c5a6c4eb4f905e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new <a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html" title="Base storage class for GPU memory with reference counting.">GpuMat</a> of given size and type. <br /></td></tr>
<tr class="separator:a715fecc85a804935c8c5a6c4eb4f905e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3555cf098c2ca2b9112f18393f6095e"><td class="memItemLeft" align="right" valign="top"><a id="ae3555cf098c2ca2b9112f18393f6095e"></a>
<a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html">GpuMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html#ae3555cf098c2ca2b9112f18393f6095e">getBuffer</a> (<a class="el" href="classcv_1_1_size__.html">Size</a> size, int type)</td></tr>
<tr class="memdesc:ae3555cf098c2ca2b9112f18393f6095e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new <a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html" title="Base storage class for GPU memory with reference counting.">GpuMat</a> of given size and type. <br /></td></tr>
<tr class="separator:ae3555cf098c2ca2b9112f18393f6095e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d639258399df2b804a88afa334b022b"><td class="memItemLeft" align="right" valign="top"><a id="a4d639258399df2b804a88afa334b022b"></a>
<a class="el" href="structcv_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classcv_1_1cuda_1_1_gpu_mat_1_1_allocator.html">GpuMat::Allocator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html#a4d639258399df2b804a88afa334b022b">getAllocator</a> () const</td></tr>
<tr class="memdesc:a4d639258399df2b804a88afa334b022b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the stream. <br /></td></tr>
<tr class="separator:a4d639258399df2b804a88afa334b022b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1e0a518847d41663e7344927515761"><td class="memItemLeft" align="right" valign="top"><a id="a0f1e0a518847d41663e7344927515761"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html#a0f1e0a518847d41663e7344927515761">BufferPool</a> (<a class="el" href="classcv_1_1cuda_1_1_stream.html">Stream</a> &amp;stream)</td></tr>
<tr class="memdesc:a0f1e0a518847d41663e7344927515761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html" title="BufferPool for use with CUDA streams.">BufferPool</a> for the given stream. <br /></td></tr>
<tr class="separator:a0f1e0a518847d41663e7344927515761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715fecc85a804935c8c5a6c4eb4f905e"><td class="memItemLeft" align="right" valign="top"><a id="a715fecc85a804935c8c5a6c4eb4f905e"></a>
<a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html">GpuMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html#a715fecc85a804935c8c5a6c4eb4f905e">getBuffer</a> (int rows, int cols, int type)</td></tr>
<tr class="memdesc:a715fecc85a804935c8c5a6c4eb4f905e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new <a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html" title="Base storage class for GPU memory with reference counting.">GpuMat</a> of given size and type. <br /></td></tr>
<tr class="separator:a715fecc85a804935c8c5a6c4eb4f905e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3555cf098c2ca2b9112f18393f6095e"><td class="memItemLeft" align="right" valign="top"><a id="ae3555cf098c2ca2b9112f18393f6095e"></a>
<a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html">GpuMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html#ae3555cf098c2ca2b9112f18393f6095e">getBuffer</a> (<a class="el" href="classcv_1_1_size__.html">Size</a> size, int type)</td></tr>
<tr class="memdesc:ae3555cf098c2ca2b9112f18393f6095e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new <a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html" title="Base storage class for GPU memory with reference counting.">GpuMat</a> of given size and type. <br /></td></tr>
<tr class="separator:ae3555cf098c2ca2b9112f18393f6095e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d639258399df2b804a88afa334b022b"><td class="memItemLeft" align="right" valign="top"><a id="a4d639258399df2b804a88afa334b022b"></a>
<a class="el" href="structcv_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classcv_1_1cuda_1_1_gpu_mat_1_1_allocator.html">GpuMat::Allocator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html#a4d639258399df2b804a88afa334b022b">getAllocator</a> () const</td></tr>
<tr class="memdesc:a4d639258399df2b804a88afa334b022b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the stream. <br /></td></tr>
<tr class="separator:a4d639258399df2b804a88afa334b022b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1e0a518847d41663e7344927515761"><td class="memItemLeft" align="right" valign="top"><a id="a0f1e0a518847d41663e7344927515761"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html#a0f1e0a518847d41663e7344927515761">BufferPool</a> (<a class="el" href="classcv_1_1cuda_1_1_stream.html">Stream</a> &amp;stream)</td></tr>
<tr class="memdesc:a0f1e0a518847d41663e7344927515761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html" title="BufferPool for use with CUDA streams.">BufferPool</a> for the given stream. <br /></td></tr>
<tr class="separator:a0f1e0a518847d41663e7344927515761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715fecc85a804935c8c5a6c4eb4f905e"><td class="memItemLeft" align="right" valign="top"><a id="a715fecc85a804935c8c5a6c4eb4f905e"></a>
<a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html">GpuMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html#a715fecc85a804935c8c5a6c4eb4f905e">getBuffer</a> (int rows, int cols, int type)</td></tr>
<tr class="memdesc:a715fecc85a804935c8c5a6c4eb4f905e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new <a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html" title="Base storage class for GPU memory with reference counting.">GpuMat</a> of given size and type. <br /></td></tr>
<tr class="separator:a715fecc85a804935c8c5a6c4eb4f905e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3555cf098c2ca2b9112f18393f6095e"><td class="memItemLeft" align="right" valign="top"><a id="ae3555cf098c2ca2b9112f18393f6095e"></a>
<a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html">GpuMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html#ae3555cf098c2ca2b9112f18393f6095e">getBuffer</a> (<a class="el" href="classcv_1_1_size__.html">Size</a> size, int type)</td></tr>
<tr class="memdesc:ae3555cf098c2ca2b9112f18393f6095e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new <a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html" title="Base storage class for GPU memory with reference counting.">GpuMat</a> of given size and type. <br /></td></tr>
<tr class="separator:ae3555cf098c2ca2b9112f18393f6095e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d639258399df2b804a88afa334b022b"><td class="memItemLeft" align="right" valign="top"><a id="a4d639258399df2b804a88afa334b022b"></a>
<a class="el" href="structcv_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classcv_1_1cuda_1_1_gpu_mat_1_1_allocator.html">GpuMat::Allocator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html#a4d639258399df2b804a88afa334b022b">getAllocator</a> () const</td></tr>
<tr class="memdesc:a4d639258399df2b804a88afa334b022b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the stream. <br /></td></tr>
<tr class="separator:a4d639258399df2b804a88afa334b022b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1e0a518847d41663e7344927515761"><td class="memItemLeft" align="right" valign="top"><a id="a0f1e0a518847d41663e7344927515761"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html#a0f1e0a518847d41663e7344927515761">BufferPool</a> (<a class="el" href="classcv_1_1cuda_1_1_stream.html">Stream</a> &amp;stream)</td></tr>
<tr class="memdesc:a0f1e0a518847d41663e7344927515761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html" title="BufferPool for use with CUDA streams.">BufferPool</a> for the given stream. <br /></td></tr>
<tr class="separator:a0f1e0a518847d41663e7344927515761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715fecc85a804935c8c5a6c4eb4f905e"><td class="memItemLeft" align="right" valign="top"><a id="a715fecc85a804935c8c5a6c4eb4f905e"></a>
<a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html">GpuMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html#a715fecc85a804935c8c5a6c4eb4f905e">getBuffer</a> (int rows, int cols, int type)</td></tr>
<tr class="memdesc:a715fecc85a804935c8c5a6c4eb4f905e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new <a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html" title="Base storage class for GPU memory with reference counting.">GpuMat</a> of given size and type. <br /></td></tr>
<tr class="separator:a715fecc85a804935c8c5a6c4eb4f905e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3555cf098c2ca2b9112f18393f6095e"><td class="memItemLeft" align="right" valign="top"><a id="ae3555cf098c2ca2b9112f18393f6095e"></a>
<a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html">GpuMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html#ae3555cf098c2ca2b9112f18393f6095e">getBuffer</a> (<a class="el" href="classcv_1_1_size__.html">Size</a> size, int type)</td></tr>
<tr class="memdesc:ae3555cf098c2ca2b9112f18393f6095e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new <a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html" title="Base storage class for GPU memory with reference counting.">GpuMat</a> of given size and type. <br /></td></tr>
<tr class="separator:ae3555cf098c2ca2b9112f18393f6095e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d639258399df2b804a88afa334b022b"><td class="memItemLeft" align="right" valign="top"><a id="a4d639258399df2b804a88afa334b022b"></a>
<a class="el" href="structcv_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classcv_1_1cuda_1_1_gpu_mat_1_1_allocator.html">GpuMat::Allocator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html#a4d639258399df2b804a88afa334b022b">getAllocator</a> () const</td></tr>
<tr class="memdesc:a4d639258399df2b804a88afa334b022b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the allocator associated with the stream. <br /></td></tr>
<tr class="separator:a4d639258399df2b804a88afa334b022b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html" title="BufferPool for use with CUDA streams.">BufferPool</a> for use with CUDA streams. </p>
<p><a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html" title="BufferPool for use with CUDA streams.">BufferPool</a> utilizes <a class="el" href="classcv_1_1cuda_1_1_stream.html" title="This class encapsulates a queue of asynchronous calls.">Stream</a>'s allocator to create new buffers for <a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html" title="Base storage class for GPU memory with reference counting.">GpuMat</a>'s. It is only useful when enabled with #setBufferPoolUsage.</p>
<div class="fragment"><div class="line"><a class="code" href="group__cudacore__struct.html#gafe63ff1578d6812ed5adfe567fde0efa">setBufferPoolUsage</a>(<span class="keyword">true</span>);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>#setBufferPoolUsage must be called <em>before</em> any <a class="el" href="classcv_1_1cuda_1_1_stream.html" title="This class encapsulates a queue of asynchronous calls.">Stream</a> declaration.</dd></dl>
<p>Users may specify custom allocator for <a class="el" href="classcv_1_1cuda_1_1_stream.html" title="This class encapsulates a queue of asynchronous calls.">Stream</a> and may implement their own stream based functions utilizing the same underlying GPU memory management.</p>
<p>If custom allocator is not specified, <a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html" title="BufferPool for use with CUDA streams.">BufferPool</a> utilizes StackAllocator by default. StackAllocator allocates a chunk of GPU device memory beforehand, and when <a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html" title="Base storage class for GPU memory with reference counting.">GpuMat</a> is declared later on, it is given the pre-allocated memory. This kind of strategy reduces the number of calls for memory allocating APIs such as cudaMalloc or cudaMallocPitch.</p>
<p>Below is an example that utilizes <a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html" title="BufferPool for use with CUDA streams.">BufferPool</a> with StackAllocator:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;opencv2/opencv.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacecv.html">cv</a>;</div><div class="line"><span class="keyword">using namespace </span>cv::cuda</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <a class="code" href="group__cudacore__struct.html#gafe63ff1578d6812ed5adfe567fde0efa">setBufferPoolUsage</a>(<span class="keyword">true</span>);                               <span class="comment">// Tell OpenCV that we are going to utilize BufferPool</span></div><div class="line">    setBufferPoolConfig(<a class="code" href="group__cudacore__init.html#gad3f2618a3f780241ac50f49123876100">getDevice</a>(), 1024 * 1024 * 64, 2);  <span class="comment">// Allocate 64 MB, 2 stacks (default is 10 MB, 5 stacks)</span></div><div class="line"></div><div class="line">    <a class="code" href="classcv_1_1cuda_1_1_stream.html">Stream</a> stream1, stream2;                                <span class="comment">// Each stream uses 1 stack</span></div><div class="line">    <a class="code" href="classcv_1_1cuda_1_1_buffer_pool.html">BufferPool</a> pool1(stream1), pool2(stream2);</div><div class="line"></div><div class="line">    <a class="code" href="classcv_1_1cuda_1_1_gpu_mat.html">GpuMat</a> d_src1 = pool1.getBuffer(4096, 4096, CV_8UC1);   <span class="comment">// 16MB</span></div><div class="line">    <a class="code" href="classcv_1_1cuda_1_1_gpu_mat.html">GpuMat</a> d_dst1 = pool1.getBuffer(4096, 4096, CV_8UC3);   <span class="comment">// 48MB, pool1 is now full</span></div><div class="line"></div><div class="line">    <a class="code" href="classcv_1_1cuda_1_1_gpu_mat.html">GpuMat</a> d_src2 = pool2.getBuffer(1024, 1024, CV_8UC1);   <span class="comment">// 1MB</span></div><div class="line">    <a class="code" href="classcv_1_1cuda_1_1_gpu_mat.html">GpuMat</a> d_dst2 = pool2.getBuffer(1024, 1024, CV_8UC3);   <span class="comment">// 3MB</span></div><div class="line"></div><div class="line">    <a class="code" href="group__imgproc__color__conversions.html#ga9cec3a213b6cda786e404a72e09247dd">cvtColor</a>(d_src1, d_dst1, CV_GRAY2BGR, 0, stream1);</div><div class="line">    <a class="code" href="group__imgproc__color__conversions.html#ga9cec3a213b6cda786e404a72e09247dd">cvtColor</a>(d_src2, d_dst2, CV_GRAY2BGR, 0, stream2);</div><div class="line">}</div></div><!-- fragment --><p>If we allocate another <a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html" title="Base storage class for GPU memory with reference counting.">GpuMat</a> on pool1 in the above example, it will be carried out by the DefaultAllocator since the stack for pool1 is full.</p>
<div class="fragment"><div class="line">GpuMat d_add1 = pool1.getBuffer(1024, 1024, CV_8UC1);   <span class="comment">// Stack for pool1 is full, memory is allocated with DefaultAllocator</span></div></div><!-- fragment --><p>If a third stream is declared in the above example, allocating with <a class="el" href="classcv_1_1cuda_1_1_buffer_pool.html#a715fecc85a804935c8c5a6c4eb4f905e" title="Allocates a new GpuMat of given size and type.">getBuffer</a> within that stream will also be carried out by the DefaultAllocator because we've run out of stacks.</p>
<div class="fragment"><div class="line">Stream stream3;                                         <span class="comment">// Only 2 stacks were allocated, we&#39;ve run out of stacks</span></div><div class="line"><a class="code" href="classcv_1_1cuda_1_1_buffer_pool.html#a0f1e0a518847d41663e7344927515761">BufferPool</a> pool3(stream3);</div><div class="line">GpuMat d_src3 = pool3.getBuffer(1024, 1024, CV_8UC1);   <span class="comment">// Memory is allocated with DefaultAllocator</span></div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>When utilizing StackAllocator, deallocation order is important.</dd></dl>
<p>Just like a stack, deallocation must be done in LIFO order. Below is an example of erroneous usage that violates LIFO rule. If <a class="el" href="interface_open_c_v.html">OpenCV</a> is compiled in Debug mode, this sample code will emit CV_Assert error.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <a class="code" href="group__cudacore__struct.html#gafe63ff1578d6812ed5adfe567fde0efa">setBufferPoolUsage</a>(<span class="keyword">true</span>);                               <span class="comment">// Tell OpenCV that we are going to utilize BufferPool</span></div><div class="line">    Stream stream;                                          <span class="comment">// A default size (10 MB) stack is allocated to this stream</span></div><div class="line">    <a class="code" href="classcv_1_1cuda_1_1_buffer_pool.html#a0f1e0a518847d41663e7344927515761">BufferPool</a> pool(stream);</div><div class="line"></div><div class="line">    GpuMat mat1 = pool.getBuffer(1024, 1024, CV_8UC1);      <span class="comment">// Allocate mat1 (1MB)</span></div><div class="line">    GpuMat mat2 = pool.getBuffer(1024, 1024, CV_8UC1);      <span class="comment">// Allocate mat2 (1MB)</span></div><div class="line"></div><div class="line">    mat1.release();                                         <span class="comment">// erroneous usage : mat2 must be deallocated before mat1</span></div><div class="line">}</div></div><!-- fragment --><p>Since C++ local variables are destroyed in the reverse order of construction, the code sample below satisfies the LIFO rule. Local <a class="el" href="classcv_1_1cuda_1_1_gpu_mat.html" title="Base storage class for GPU memory with reference counting.">GpuMat</a>'s are deallocated and the corresponding memory is automatically returned to the pool for later usage.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <a class="code" href="group__cudacore__struct.html#gafe63ff1578d6812ed5adfe567fde0efa">setBufferPoolUsage</a>(<span class="keyword">true</span>);                               <span class="comment">// Tell OpenCV that we are going to utilize BufferPool</span></div><div class="line">    setBufferPoolConfig(<a class="code" href="group__cudacore__init.html#gad3f2618a3f780241ac50f49123876100">getDevice</a>(), 1024 * 1024 * 64, 2);  <span class="comment">// Allocate 64 MB, 2 stacks (default is 10 MB, 5 stacks)</span></div><div class="line"></div><div class="line">    Stream stream1, stream2;                                <span class="comment">// Each stream uses 1 stack</span></div><div class="line">    <a class="code" href="classcv_1_1cuda_1_1_buffer_pool.html#a0f1e0a518847d41663e7344927515761">BufferPool</a> pool1(stream1), pool2(stream2);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; i++)</div><div class="line">    {</div><div class="line">        GpuMat d_src1 = pool1.getBuffer(4096, 4096, CV_8UC1);   <span class="comment">// 16MB</span></div><div class="line">        GpuMat d_dst1 = pool1.getBuffer(4096, 4096, CV_8UC3);   <span class="comment">// 48MB, pool1 is now full</span></div><div class="line"></div><div class="line">        GpuMat d_src2 = pool2.getBuffer(1024, 1024, CV_8UC1);   <span class="comment">// 1MB</span></div><div class="line">        GpuMat d_dst2 = pool2.getBuffer(1024, 1024, CV_8UC3);   <span class="comment">// 3MB</span></div><div class="line"></div><div class="line">        d_src1.<a class="code" href="classcv_1_1cuda_1_1_gpu_mat.html#ab263999dea4f7f28d4dd4ced6d2e970b">setTo</a>(Scalar(i), stream1);</div><div class="line">        d_src2.<a class="code" href="classcv_1_1cuda_1_1_gpu_mat.html#ab263999dea4f7f28d4dd4ced6d2e970b">setTo</a>(Scalar(i), stream2);</div><div class="line"></div><div class="line">        <a class="code" href="group__imgproc__color__conversions.html#ga9cec3a213b6cda786e404a72e09247dd">cvtColor</a>(d_src1, d_dst1, CV_GRAY2BGR, 0, stream1);</div><div class="line">        <a class="code" href="group__imgproc__color__conversions.html#ga9cec3a213b6cda786e404a72e09247dd">cvtColor</a>(d_src2, d_dst2, CV_GRAY2BGR, 0, stream2);</div><div class="line">                                                                <span class="comment">// The order of destruction of the local variables is:</span></div><div class="line">                                                                <span class="comment">//   d_dst2 =&gt; d_src2 =&gt; d_dst1 =&gt; d_src1</span></div><div class="line">                                                                <span class="comment">// LIFO rule is satisfied, this code runs without error</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> </div><hr/>The documentation for this class was generated from the following file:<ul>
<li>PixUl8/OpenCV/opencv2.framework/Versions/A/Headers/core/<a class="el" href="_open_c_v_2opencv2_8framework_2_versions_2_a_2_headers_2core_2cuda_8hpp_source.html">cuda.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
