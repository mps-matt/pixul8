<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PixUl8: Imgproc_feature</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PixUl8
   &#160;<span id="projectnumber">3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Imgproc_feature<div class="ingroups"><a class="el" href="group__imgproc.html">Image Processing</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_line_segment_detector.html">cv::LineSegmentDetector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Line segment detector class.  <a href="classcv_1_1_line_segment_detector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga073687a5b96ac7a3ab5802eb5510fe65"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#ga073687a5b96ac7a3ab5802eb5510fe65">cv::HoughModes</a> { <br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3
<br />
 }</td></tr>
<tr class="memdesc:ga073687a5b96ac7a3ab5802eb5510fe65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of a Hough transform.  <a href="group__imgproc__feature.html#ga073687a5b96ac7a3ab5802eb5510fe65">More...</a><br /></td></tr>
<tr class="separator:ga073687a5b96ac7a3ab5802eb5510fe65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad092a7362b8afb8a905238a41898d98c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#gad092a7362b8afb8a905238a41898d98c">cv::LineSegmentDetectorModes</a> { <br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2
<br />
 }</td></tr>
<tr class="memdesc:gad092a7362b8afb8a905238a41898d98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of Line Segment Detector.  <a href="group__imgproc__feature.html#gad092a7362b8afb8a905238a41898d98c">More...</a><br /></td></tr>
<tr class="separator:gad092a7362b8afb8a905238a41898d98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga073687a5b96ac7a3ab5802eb5510fe65"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#ga073687a5b96ac7a3ab5802eb5510fe65">cv::HoughModes</a> { <br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3
<br />
 }</td></tr>
<tr class="memdesc:ga073687a5b96ac7a3ab5802eb5510fe65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of a Hough transform.  <a href="group__imgproc__feature.html#ga073687a5b96ac7a3ab5802eb5510fe65">More...</a><br /></td></tr>
<tr class="separator:ga073687a5b96ac7a3ab5802eb5510fe65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad092a7362b8afb8a905238a41898d98c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#gad092a7362b8afb8a905238a41898d98c">cv::LineSegmentDetectorModes</a> { <br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2
<br />
 }</td></tr>
<tr class="memdesc:gad092a7362b8afb8a905238a41898d98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of Line Segment Detector.  <a href="group__imgproc__feature.html#gad092a7362b8afb8a905238a41898d98c">More...</a><br /></td></tr>
<tr class="separator:gad092a7362b8afb8a905238a41898d98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga073687a5b96ac7a3ab5802eb5510fe65"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#ga073687a5b96ac7a3ab5802eb5510fe65">cv::HoughModes</a> { <br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3
<br />
 }</td></tr>
<tr class="memdesc:ga073687a5b96ac7a3ab5802eb5510fe65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of a Hough transform.  <a href="group__imgproc__feature.html#ga073687a5b96ac7a3ab5802eb5510fe65">More...</a><br /></td></tr>
<tr class="separator:ga073687a5b96ac7a3ab5802eb5510fe65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad092a7362b8afb8a905238a41898d98c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#gad092a7362b8afb8a905238a41898d98c">cv::LineSegmentDetectorModes</a> { <br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2
<br />
 }</td></tr>
<tr class="memdesc:gad092a7362b8afb8a905238a41898d98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of Line Segment Detector.  <a href="group__imgproc__feature.html#gad092a7362b8afb8a905238a41898d98c">More...</a><br /></td></tr>
<tr class="separator:gad092a7362b8afb8a905238a41898d98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga073687a5b96ac7a3ab5802eb5510fe65"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#ga073687a5b96ac7a3ab5802eb5510fe65">cv::HoughModes</a> { <br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3
<br />
 }</td></tr>
<tr class="memdesc:ga073687a5b96ac7a3ab5802eb5510fe65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of a Hough transform.  <a href="group__imgproc__feature.html#ga073687a5b96ac7a3ab5802eb5510fe65">More...</a><br /></td></tr>
<tr class="separator:ga073687a5b96ac7a3ab5802eb5510fe65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad092a7362b8afb8a905238a41898d98c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#gad092a7362b8afb8a905238a41898d98c">cv::LineSegmentDetectorModes</a> { <br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2
<br />
 }</td></tr>
<tr class="memdesc:gad092a7362b8afb8a905238a41898d98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of Line Segment Detector.  <a href="group__imgproc__feature.html#gad092a7362b8afb8a905238a41898d98c">More...</a><br /></td></tr>
<tr class="separator:gad092a7362b8afb8a905238a41898d98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga073687a5b96ac7a3ab5802eb5510fe65"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#ga073687a5b96ac7a3ab5802eb5510fe65">cv::HoughModes</a> { <br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262">cv::HOUGH_STANDARD</a> = 0, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f">cv::HOUGH_PROBABILISTIC</a> = 1, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae">cv::HOUGH_MULTI_SCALE</a> = 2, 
<a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f">cv::HOUGH_GRADIENT</a> = 3
<br />
 }</td></tr>
<tr class="memdesc:ga073687a5b96ac7a3ab5802eb5510fe65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of a Hough transform.  <a href="group__imgproc__feature.html#ga073687a5b96ac7a3ab5802eb5510fe65">More...</a><br /></td></tr>
<tr class="separator:ga073687a5b96ac7a3ab5802eb5510fe65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad092a7362b8afb8a905238a41898d98c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#gad092a7362b8afb8a905238a41898d98c">cv::LineSegmentDetectorModes</a> { <br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85">cv::LSD_REFINE_NONE</a> = 0, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">cv::LSD_REFINE_STD</a> = 1, 
<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81">cv::LSD_REFINE_ADV</a> = 2
<br />
 }</td></tr>
<tr class="memdesc:gad092a7362b8afb8a905238a41898d98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variants of Line Segment Detector.  <a href="group__imgproc__feature.html#gad092a7362b8afb8a905238a41898d98c">More...</a><br /></td></tr>
<tr class="separator:gad092a7362b8afb8a905238a41898d98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga414a47fa161a519aa9943ea3f7890d84"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W <a class="el" href="structcv_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classcv_1_1_line_segment_detector.html">LineSegmentDetector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#ga414a47fa161a519aa9943ea3f7890d84">cv::createLineSegmentDetector</a> (int _refine=<a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">LSD_REFINE_STD</a>, double _scale=0.8, double _sigma_scale=0.6, double _quant=2.0, double _ang_th=22.5, double _log_eps=0, double _density_th=0.7, int _n_bins=1024)</td></tr>
<tr class="memdesc:ga414a47fa161a519aa9943ea3f7890d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a smart pointer to a <a class="el" href="classcv_1_1_line_segment_detector.html" title="Line segment detector class.">LineSegmentDetector</a> object and initializes it.  <a href="group__imgproc__feature.html#ga414a47fa161a519aa9943ea3f7890d84">More...</a><br /></td></tr>
<tr class="separator:ga414a47fa161a519aa9943ea3f7890d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad744b1c88d72215c5a79b2b90e9f5bda"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#gad744b1c88d72215c5a79b2b90e9f5bda">cv::Canny</a> (InputArray image, <a class="el" href="classcv_1_1___output_array.html">OutputArray</a> edges, double threshold1, double threshold2, int apertureSize=3, bool L2gradient=false)</td></tr>
<tr class="memdesc:gad744b1c88d72215c5a79b2b90e9f5bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds edges in an image using the Canny algorithm <b>[Canny86]</b> .  <a href="group__imgproc__feature.html#gad744b1c88d72215c5a79b2b90e9f5bda">More...</a><br /></td></tr>
<tr class="separator:gad744b1c88d72215c5a79b2b90e9f5bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga445e2749861910fefe0db944a09e5eac"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#ga445e2749861910fefe0db944a09e5eac">cv::Canny</a> (InputArray dx, InputArray dy, <a class="el" href="classcv_1_1___output_array.html">OutputArray</a> edges, double threshold1, double threshold2, bool L2gradient=false)</td></tr>
<tr class="separator:ga445e2749861910fefe0db944a09e5eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga363ae1047b9f246e78a82a2862c6cde8"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#ga363ae1047b9f246e78a82a2862c6cde8">cv::cornerMinEigenVal</a> (InputArray src, <a class="el" href="classcv_1_1___output_array.html">OutputArray</a> dst, int blockSize, int ksize=3, int borderType=<a class="el" href="group__core__array.html#gga209f2f4869e304c82d07739337eae7c5a43f0bbcfa6f8895c6cc31b5ce0a2aa8a">BORDER_DEFAULT</a>)</td></tr>
<tr class="memdesc:ga363ae1047b9f246e78a82a2862c6cde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the minimal eigenvalue of gradient matrices for corner detection.  <a href="group__imgproc__feature.html#ga363ae1047b9f246e78a82a2862c6cde8">More...</a><br /></td></tr>
<tr class="separator:ga363ae1047b9f246e78a82a2862c6cde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ce7d0d38d83ef14e335b87c384f39dd"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#ga5ce7d0d38d83ef14e335b87c384f39dd">cv::cornerHarris</a> (InputArray src, <a class="el" href="classcv_1_1___output_array.html">OutputArray</a> dst, int blockSize, int ksize, double k, int borderType=<a class="el" href="group__core__array.html#gga209f2f4869e304c82d07739337eae7c5a43f0bbcfa6f8895c6cc31b5ce0a2aa8a">BORDER_DEFAULT</a>)</td></tr>
<tr class="memdesc:ga5ce7d0d38d83ef14e335b87c384f39dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Harris corner detector.  <a href="group__imgproc__feature.html#ga5ce7d0d38d83ef14e335b87c384f39dd">More...</a><br /></td></tr>
<tr class="separator:ga5ce7d0d38d83ef14e335b87c384f39dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52dcea91b777bb8f1a506a9f91977aab"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#ga52dcea91b777bb8f1a506a9f91977aab">cv::cornerEigenValsAndVecs</a> (InputArray src, <a class="el" href="classcv_1_1___output_array.html">OutputArray</a> dst, int blockSize, int ksize, int borderType=<a class="el" href="group__core__array.html#gga209f2f4869e304c82d07739337eae7c5a43f0bbcfa6f8895c6cc31b5ce0a2aa8a">BORDER_DEFAULT</a>)</td></tr>
<tr class="memdesc:ga52dcea91b777bb8f1a506a9f91977aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates eigenvalues and eigenvectors of image blocks for corner detection.  <a href="group__imgproc__feature.html#ga52dcea91b777bb8f1a506a9f91977aab">More...</a><br /></td></tr>
<tr class="separator:ga52dcea91b777bb8f1a506a9f91977aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6967f1a104b733917d4da9685816cf4"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#gac6967f1a104b733917d4da9685816cf4">cv::preCornerDetect</a> (InputArray src, <a class="el" href="classcv_1_1___output_array.html">OutputArray</a> dst, int ksize, int borderType=<a class="el" href="group__core__array.html#gga209f2f4869e304c82d07739337eae7c5a43f0bbcfa6f8895c6cc31b5ce0a2aa8a">BORDER_DEFAULT</a>)</td></tr>
<tr class="memdesc:gac6967f1a104b733917d4da9685816cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a feature map for corner detection.  <a href="group__imgproc__feature.html#gac6967f1a104b733917d4da9685816cf4">More...</a><br /></td></tr>
<tr class="separator:gac6967f1a104b733917d4da9685816cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4310d06f13813830106e63fe519ba642"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#ga4310d06f13813830106e63fe519ba642">cv::cornerSubPix</a> (InputArray image, <a class="el" href="classcv_1_1___input_output_array.html">InputOutputArray</a> corners, <a class="el" href="classcv_1_1_size__.html">Size</a> winSize, <a class="el" href="classcv_1_1_size__.html">Size</a> zeroZone, <a class="el" href="classcv_1_1_term_criteria.html">TermCriteria</a> criteria)</td></tr>
<tr class="memdesc:ga4310d06f13813830106e63fe519ba642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines the corner locations.  <a href="group__imgproc__feature.html#ga4310d06f13813830106e63fe519ba642">More...</a><br /></td></tr>
<tr class="separator:ga4310d06f13813830106e63fe519ba642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19e8a8000230fae9736fe837b516a1d1"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#ga19e8a8000230fae9736fe837b516a1d1">cv::goodFeaturesToTrack</a> (InputArray image, <a class="el" href="classcv_1_1___output_array.html">OutputArray</a> corners, int maxCorners, double qualityLevel, double minDistance, InputArray mask=noArray(), int blockSize=3, bool useHarrisDetector=false, double k=0.04)</td></tr>
<tr class="memdesc:ga19e8a8000230fae9736fe837b516a1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines strong corners on an image.  <a href="group__imgproc__feature.html#ga19e8a8000230fae9736fe837b516a1d1">More...</a><br /></td></tr>
<tr class="separator:ga19e8a8000230fae9736fe837b516a1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga771d92e404bec92c8bbfe92b9bbf5f3b"><td class="memItemLeft" align="right" valign="top"><a id="ga771d92e404bec92c8bbfe92b9bbf5f3b"></a>
CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><b>cv::goodFeaturesToTrack</b> (InputArray image, <a class="el" href="classcv_1_1___output_array.html">OutputArray</a> corners, int maxCorners, double qualityLevel, double minDistance, InputArray mask, int blockSize, int gradientSize, bool useHarrisDetector=false, double k=0.04)</td></tr>
<tr class="separator:ga771d92e404bec92c8bbfe92b9bbf5f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f2f4ef61facc51f7fb249be61801fa6"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#ga0f2f4ef61facc51f7fb249be61801fa6">cv::HoughLines</a> (InputArray image, <a class="el" href="classcv_1_1___output_array.html">OutputArray</a> lines, double rho, double theta, int <a class="el" href="group__imgproc__misc.html#gabd93e7119f2b85135109ab4b1f4f9eaf">threshold</a>, double srn=0, double stn=0, double min_theta=0, double max_theta=CV_PI)</td></tr>
<tr class="memdesc:ga0f2f4ef61facc51f7fb249be61801fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds lines in a binary image using the standard Hough transform.  <a href="group__imgproc__feature.html#ga0f2f4ef61facc51f7fb249be61801fa6">More...</a><br /></td></tr>
<tr class="separator:ga0f2f4ef61facc51f7fb249be61801fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga184ca047da5a47af50bc7ff411cc8349"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#ga184ca047da5a47af50bc7ff411cc8349">cv::HoughLinesP</a> (InputArray image, <a class="el" href="classcv_1_1___output_array.html">OutputArray</a> lines, double rho, double theta, int <a class="el" href="group__imgproc__misc.html#gabd93e7119f2b85135109ab4b1f4f9eaf">threshold</a>, double minLineLength=0, double maxLineGap=0)</td></tr>
<tr class="memdesc:ga184ca047da5a47af50bc7ff411cc8349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds line segments in a binary image using the probabilistic Hough transform.  <a href="group__imgproc__feature.html#ga184ca047da5a47af50bc7ff411cc8349">More...</a><br /></td></tr>
<tr class="separator:ga184ca047da5a47af50bc7ff411cc8349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d43819de9c06b703ecf4475d21936d4"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#ga6d43819de9c06b703ecf4475d21936d4">cv::HoughLinesPointSet</a> (InputArray _point, <a class="el" href="classcv_1_1___output_array.html">OutputArray</a> _lines, int lines_max, int <a class="el" href="group__imgproc__misc.html#gabd93e7119f2b85135109ab4b1f4f9eaf">threshold</a>, double min_rho, double max_rho, double rho_step, double min_theta, double max_theta, double theta_step)</td></tr>
<tr class="memdesc:ga6d43819de9c06b703ecf4475d21936d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds lines in a set of points using the standard Hough transform.  <a href="group__imgproc__feature.html#ga6d43819de9c06b703ecf4475d21936d4">More...</a><br /></td></tr>
<tr class="separator:ga6d43819de9c06b703ecf4475d21936d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87c2c2adf271356817c8636c5ef8a738"><td class="memItemLeft" align="right" valign="top">CV_EXPORTS_W void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__imgproc__feature.html#ga87c2c2adf271356817c8636c5ef8a738">cv::HoughCircles</a> (InputArray image, <a class="el" href="classcv_1_1___output_array.html">OutputArray</a> circles, int method, double dp, double minDist, double param1=100, double param2=100, int minRadius=0, int maxRadius=0)</td></tr>
<tr class="memdesc:ga87c2c2adf271356817c8636c5ef8a738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds circles in a grayscale image using the Hough transform.  <a href="group__imgproc__feature.html#ga87c2c2adf271356817c8636c5ef8a738">More...</a><br /></td></tr>
<tr class="separator:ga87c2c2adf271356817c8636c5ef8a738"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga073687a5b96ac7a3ab5802eb5510fe65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga073687a5b96ac7a3ab5802eb5510fe65">&#9670;&nbsp;</a></span>HoughModes <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__imgproc__feature.html#ga073687a5b96ac7a3ab5802eb5510fe65">cv::HoughModes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of a Hough transform. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
</table>

</div>
</div>
<a id="ga073687a5b96ac7a3ab5802eb5510fe65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga073687a5b96ac7a3ab5802eb5510fe65">&#9670;&nbsp;</a></span>HoughModes <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__imgproc__feature.html#ga073687a5b96ac7a3ab5802eb5510fe65">cv::HoughModes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of a Hough transform. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
</table>

</div>
</div>
<a id="ga073687a5b96ac7a3ab5802eb5510fe65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga073687a5b96ac7a3ab5802eb5510fe65">&#9670;&nbsp;</a></span>HoughModes <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__imgproc__feature.html#ga073687a5b96ac7a3ab5802eb5510fe65">cv::HoughModes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of a Hough transform. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
</table>

</div>
</div>
<a id="ga073687a5b96ac7a3ab5802eb5510fe65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga073687a5b96ac7a3ab5802eb5510fe65">&#9670;&nbsp;</a></span>HoughModes <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__imgproc__feature.html#ga073687a5b96ac7a3ab5802eb5510fe65">cv::HoughModes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of a Hough transform. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
</table>

</div>
</div>
<a id="ga073687a5b96ac7a3ab5802eb5510fe65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga073687a5b96ac7a3ab5802eb5510fe65">&#9670;&nbsp;</a></span>HoughModes <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__imgproc__feature.html#ga073687a5b96ac7a3ab5802eb5510fe65">cv::HoughModes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of a Hough transform. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ad7c0ba512e20b8e7ce87f18f532a4262"></a>HOUGH_STANDARD&#160;</td><td class="fielddoc"><p>classical or standard Hough transform. Every line is represented by two floating-point numbers <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> , where <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is a distance between (0,0) point and the line, and <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ae624f73faf5cbd147f23a81be328ec9f"></a>HOUGH_PROBABILISTIC&#160;</td><td class="fielddoc"><p>probabilistic Hough transform (more efficient in case if the picture contains a few long linear segments). It returns line segments rather than the whole line. Each segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of the CV_32SC4 type. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65a4b537628d69c2f0bae052312a141c4ae"></a>HOUGH_MULTI_SCALE&#160;</td><td class="fielddoc"><p>multi-scale variant of the classical Hough transform. The lines are encoded the same way as HOUGH_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f"></a>HOUGH_GRADIENT&#160;</td><td class="fielddoc"><p>basically <em>21HT</em>, described in <b>[Yuen90]</b> </p>
</td></tr>
</table>

</div>
</div>
<a id="gad092a7362b8afb8a905238a41898d98c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad092a7362b8afb8a905238a41898d98c">&#9670;&nbsp;</a></span>LineSegmentDetectorModes <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__imgproc__feature.html#gad092a7362b8afb8a905238a41898d98c">cv::LineSegmentDetectorModes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of Line Segment Detector. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
</table>

</div>
</div>
<a id="gad092a7362b8afb8a905238a41898d98c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad092a7362b8afb8a905238a41898d98c">&#9670;&nbsp;</a></span>LineSegmentDetectorModes <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__imgproc__feature.html#gad092a7362b8afb8a905238a41898d98c">cv::LineSegmentDetectorModes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of Line Segment Detector. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
</table>

</div>
</div>
<a id="gad092a7362b8afb8a905238a41898d98c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad092a7362b8afb8a905238a41898d98c">&#9670;&nbsp;</a></span>LineSegmentDetectorModes <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__imgproc__feature.html#gad092a7362b8afb8a905238a41898d98c">cv::LineSegmentDetectorModes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of Line Segment Detector. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
</table>

</div>
</div>
<a id="gad092a7362b8afb8a905238a41898d98c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad092a7362b8afb8a905238a41898d98c">&#9670;&nbsp;</a></span>LineSegmentDetectorModes <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__imgproc__feature.html#gad092a7362b8afb8a905238a41898d98c">cv::LineSegmentDetectorModes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of Line Segment Detector. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
</table>

</div>
</div>
<a id="gad092a7362b8afb8a905238a41898d98c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad092a7362b8afb8a905238a41898d98c">&#9670;&nbsp;</a></span>LineSegmentDetectorModes <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__imgproc__feature.html#gad092a7362b8afb8a905238a41898d98c">cv::LineSegmentDetectorModes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variants of Line Segment Detector. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca4b15c906906a343a04a60f382738bb85"></a>LSD_REFINE_NONE&#160;</td><td class="fielddoc"><p>No refinement applied. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab"></a>LSD_REFINE_STD&#160;</td><td class="fielddoc"><p>Standard refinement is applied. E.g. breaking arches into smaller straighter line approximations. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad092a7362b8afb8a905238a41898d98ca9175f5f8e4ab306043fb0ab6b2e9cc81"></a>LSD_REFINE_ADV&#160;</td><td class="fielddoc"><p>Advanced refinement. Number of false alarms is calculated, lines are refined through increase of precision, decrement in size, etc. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad744b1c88d72215c5a79b2b90e9f5bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad744b1c88d72215c5a79b2b90e9f5bda">&#9670;&nbsp;</a></span>Canny() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS_W void cv::Canny </td>
          <td>(</td>
          <td class="paramtype">InputArray&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1___output_array.html">OutputArray</a>&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>apertureSize</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>L2gradient</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds edges in an image using the Canny algorithm <b>[Canny86]</b> . </p>
<p>The function finds edges in the input image and marks them in the output map edges using the Canny algorithm. The smallest value between threshold1 and threshold2 is used for edge linking. The largest value is used to find initial segments of strong edges. See <a href="http://en.wikipedia.org/wiki/Canny_edge_detector">http://en.wikipedia.org/wiki/Canny_edge_detector</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>8-bit input image. </td></tr>
    <tr><td class="paramname">edges</td><td>output edge map; single channels 8-bit image, which has the same size as image . </td></tr>
    <tr><td class="paramname">threshold1</td><td>first threshold for the hysteresis procedure. </td></tr>
    <tr><td class="paramname">threshold2</td><td>second threshold for the hysteresis procedure. </td></tr>
    <tr><td class="paramname">apertureSize</td><td>aperture size for the Sobel operator. </td></tr>
    <tr><td class="paramname">L2gradient</td><td>a flag, indicating whether a more accurate <img class="formulaInl" alt="$L_2$" src="form_431.png"/> norm <img class="formulaInl" alt="$=\sqrt{(dI/dx)^2 + (dI/dy)^2}$" src="form_432.png"/> should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default <img class="formulaInl" alt="$L_1$" src="form_433.png"/> norm <img class="formulaInl" alt="$=|dI/dx|+|dI/dy|$" src="form_434.png"/> is enough ( L2gradient=false ). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga445e2749861910fefe0db944a09e5eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga445e2749861910fefe0db944a09e5eac">&#9670;&nbsp;</a></span>Canny() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS_W void cv::Canny </td>
          <td>(</td>
          <td class="paramtype">InputArray&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputArray&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1___output_array.html">OutputArray</a>&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>L2gradient</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>Finds edges in an image using the Canny algorithm with custom image gradient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>16-bit x derivative of input image (CV_16SC1 or CV_16SC3). </td></tr>
    <tr><td class="paramname">dy</td><td>16-bit y derivative of input image (same type as dx). </td></tr>
    <tr><td class="paramname">edges</td><td>output edge map; single channels 8-bit image, which has the same size as image . </td></tr>
    <tr><td class="paramname">threshold1</td><td>first threshold for the hysteresis procedure. </td></tr>
    <tr><td class="paramname">threshold2</td><td>second threshold for the hysteresis procedure. </td></tr>
    <tr><td class="paramname">L2gradient</td><td>a flag, indicating whether a more accurate <img class="formulaInl" alt="$L_2$" src="form_431.png"/> norm <img class="formulaInl" alt="$=\sqrt{(dI/dx)^2 + (dI/dy)^2}$" src="form_432.png"/> should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default <img class="formulaInl" alt="$L_1$" src="form_433.png"/> norm <img class="formulaInl" alt="$=|dI/dx|+|dI/dy|$" src="form_434.png"/> is enough ( L2gradient=false ). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga52dcea91b777bb8f1a506a9f91977aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52dcea91b777bb8f1a506a9f91977aab">&#9670;&nbsp;</a></span>cornerEigenValsAndVecs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS_W void cv::cornerEigenValsAndVecs </td>
          <td>(</td>
          <td class="paramtype">InputArray&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1___output_array.html">OutputArray</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em> = <code><a class="el" href="group__core__array.html#gga209f2f4869e304c82d07739337eae7c5a43f0bbcfa6f8895c6cc31b5ce0a2aa8a">BORDER_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates eigenvalues and eigenvectors of image blocks for corner detection. </p>
<p>For every pixel <img class="formulaInl" alt="$p$" src="form_440.png"/> , the function cornerEigenValsAndVecs considers a blockSize <img class="formulaInl" alt="$\times$" src="form_441.png"/> blockSize neighborhood <img class="formulaInl" alt="$S(p)$" src="form_442.png"/> . It calculates the covariation matrix of derivatives over the neighborhood as:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[M = \begin{bmatrix} \sum _{S(p)}(dI/dx)^2 &amp; \sum _{S(p)}dI/dx dI/dy \\ \sum _{S(p)}dI/dx dI/dy &amp; \sum _{S(p)}(dI/dy)^2 \end{bmatrix}\]" src="form_443.png"/>
</p>
<p>where the derivatives are computed using the Sobel operator.</p>
<p>After that, it finds eigenvectors and eigenvalues of <img class="formulaInl" alt="$M$" src="form_444.png"/> and stores them in the destination image as <img class="formulaInl" alt="$(\lambda_1, \lambda_2, x_1, y_1, x_2, y_2)$" src="form_445.png"/> where</p>
<ul>
<li><img class="formulaInl" alt="$\lambda_1, \lambda_2$" src="form_446.png"/> are the non-sorted eigenvalues of <img class="formulaInl" alt="$M$" src="form_444.png"/></li>
<li><img class="formulaInl" alt="$x_1, y_1$" src="form_447.png"/> are the eigenvectors corresponding to <img class="formulaInl" alt="$\lambda_1$" src="form_448.png"/></li>
<li><img class="formulaInl" alt="$x_2, y_2$" src="form_449.png"/> are the eigenvectors corresponding to <img class="formulaInl" alt="$\lambda_2$" src="form_450.png"/></li>
</ul>
<p>The output of the function can be used for robust edge or corner detection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Input single-channel 8-bit or floating-point image. </td></tr>
    <tr><td class="paramname">dst</td><td>Image to store the results. It has the same size as src and the type CV_32FC(6) . </td></tr>
    <tr><td class="paramname">blockSize</td><td>Neighborhood size (see details below). </td></tr>
    <tr><td class="paramname">ksize</td><td>Aperture parameter for the Sobel operator. </td></tr>
    <tr><td class="paramname">borderType</td><td>Pixel extrapolation method. See <a class="el" href="group__core__array.html#ga209f2f4869e304c82d07739337eae7c5">BorderTypes</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__imgproc__feature.html#ga363ae1047b9f246e78a82a2862c6cde8" title="Calculates the minimal eigenvalue of gradient matrices for corner detection.">cornerMinEigenVal</a>, <a class="el" href="group__imgproc__feature.html#ga5ce7d0d38d83ef14e335b87c384f39dd" title="Harris corner detector.">cornerHarris</a>, <a class="el" href="group__imgproc__feature.html#gac6967f1a104b733917d4da9685816cf4" title="Calculates a feature map for corner detection.">preCornerDetect</a> </dd></dl>

</div>
</div>
<a id="ga5ce7d0d38d83ef14e335b87c384f39dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ce7d0d38d83ef14e335b87c384f39dd">&#9670;&nbsp;</a></span>cornerHarris()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS_W void cv::cornerHarris </td>
          <td>(</td>
          <td class="paramtype">InputArray&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1___output_array.html">OutputArray</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em> = <code><a class="el" href="group__core__array.html#gga209f2f4869e304c82d07739337eae7c5a43f0bbcfa6f8895c6cc31b5ce0a2aa8a">BORDER_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Harris corner detector. </p>
<p>The function runs the Harris corner detector on the image. Similarly to cornerMinEigenVal and cornerEigenValsAndVecs , for each pixel <img class="formulaInl" alt="$(x, y)$" src="form_391.png"/> it calculates a <img class="formulaInl" alt="$2\times2$" src="form_436.png"/> gradient covariance matrix <img class="formulaInl" alt="$M^{(x,y)}$" src="form_437.png"/> over a <img class="formulaInl" alt="$\texttt{blockSize} \times \texttt{blockSize}$" src="form_438.png"/> neighborhood. Then, it computes the following characteristic:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\texttt{dst} (x,y) = \mathrm{det} M^{(x,y)} - k \cdot \left ( \mathrm{tr} M^{(x,y)} \right )^2\]" src="form_439.png"/>
</p>
<p>Corners in the image can be found as the local maxima of this response map.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Input single-channel 8-bit or floating-point image. </td></tr>
    <tr><td class="paramname">dst</td><td>Image to store the Harris detector responses. It has the type CV_32FC1 and the same size as src . </td></tr>
    <tr><td class="paramname">blockSize</td><td>Neighborhood size (see the details on <a class="el" href="group__imgproc__feature.html#ga52dcea91b777bb8f1a506a9f91977aab" title="Calculates eigenvalues and eigenvectors of image blocks for corner detection.">cornerEigenValsAndVecs</a> ). </td></tr>
    <tr><td class="paramname">ksize</td><td>Aperture parameter for the Sobel operator. </td></tr>
    <tr><td class="paramname">k</td><td>Harris detector free parameter. See the formula above. </td></tr>
    <tr><td class="paramname">borderType</td><td>Pixel extrapolation method. See <a class="el" href="group__core__array.html#ga209f2f4869e304c82d07739337eae7c5">BorderTypes</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga363ae1047b9f246e78a82a2862c6cde8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga363ae1047b9f246e78a82a2862c6cde8">&#9670;&nbsp;</a></span>cornerMinEigenVal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS_W void cv::cornerMinEigenVal </td>
          <td>(</td>
          <td class="paramtype">InputArray&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1___output_array.html">OutputArray</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em> = <code><a class="el" href="group__core__array.html#gga209f2f4869e304c82d07739337eae7c5a43f0bbcfa6f8895c6cc31b5ce0a2aa8a">BORDER_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the minimal eigenvalue of gradient matrices for corner detection. </p>
<p>The function is similar to cornerEigenValsAndVecs but it calculates and stores only the minimal eigenvalue of the covariance matrix of derivatives, that is, <img class="formulaInl" alt="$\min(\lambda_1, \lambda_2)$" src="form_435.png"/> in terms of the formulae in the cornerEigenValsAndVecs description.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Input single-channel 8-bit or floating-point image. </td></tr>
    <tr><td class="paramname">dst</td><td>Image to store the minimal eigenvalues. It has the type CV_32FC1 and the same size as src . </td></tr>
    <tr><td class="paramname">blockSize</td><td>Neighborhood size (see the details on <a class="el" href="group__imgproc__feature.html#ga52dcea91b777bb8f1a506a9f91977aab" title="Calculates eigenvalues and eigenvectors of image blocks for corner detection.">cornerEigenValsAndVecs</a> ). </td></tr>
    <tr><td class="paramname">ksize</td><td>Aperture parameter for the Sobel operator. </td></tr>
    <tr><td class="paramname">borderType</td><td>Pixel extrapolation method. See <a class="el" href="group__core__array.html#ga209f2f4869e304c82d07739337eae7c5">BorderTypes</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4310d06f13813830106e63fe519ba642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4310d06f13813830106e63fe519ba642">&#9670;&nbsp;</a></span>cornerSubPix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS_W void cv::cornerSubPix </td>
          <td>(</td>
          <td class="paramtype">InputArray&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1___input_output_array.html">InputOutputArray</a>&#160;</td>
          <td class="paramname"><em>corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1_size__.html">Size</a>&#160;</td>
          <td class="paramname"><em>winSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1_size__.html">Size</a>&#160;</td>
          <td class="paramname"><em>zeroZone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1_term_criteria.html">TermCriteria</a>&#160;</td>
          <td class="paramname"><em>criteria</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refines the corner locations. </p>
<p>The function iterates to find the sub-pixel accurate location of corners or radial saddle points, as shown on the figure below.</p>
<img src="pics/cornersubpix.png" alt="image" class="inline"/>
<p>Sub-pixel accurate corner locator is based on the observation that every vector from the center <img class="formulaInl" alt="$q$" src="form_457.png"/> to a point <img class="formulaInl" alt="$p$" src="form_440.png"/> located within a neighborhood of <img class="formulaInl" alt="$q$" src="form_457.png"/> is orthogonal to the image gradient at <img class="formulaInl" alt="$p$" src="form_440.png"/> subject to image and measurement noise. Consider the expression:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\epsilon _i = {DI_{p_i}}^T \cdot (q - p_i)\]" src="form_458.png"/>
</p>
<p>where <img class="formulaInl" alt="${DI_{p_i}}$" src="form_459.png"/> is an image gradient at one of the points <img class="formulaInl" alt="$p_i$" src="form_460.png"/> in a neighborhood of <img class="formulaInl" alt="$q$" src="form_457.png"/> . The value of <img class="formulaInl" alt="$q$" src="form_457.png"/> is to be found so that <img class="formulaInl" alt="$\epsilon_i$" src="form_461.png"/> is minimized. A system of equations may be set up with <img class="formulaInl" alt="$\epsilon_i$" src="form_461.png"/> set to zero:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\sum _i(DI_{p_i} \cdot {DI_{p_i}}^T) \cdot q - \sum _i(DI_{p_i} \cdot {DI_{p_i}}^T \cdot p_i)\]" src="form_462.png"/>
</p>
<p>where the gradients are summed within a neighborhood ("search window") of <img class="formulaInl" alt="$q$" src="form_457.png"/> . Calling the first gradient term <img class="formulaInl" alt="$G$" src="form_463.png"/> and the second gradient term <img class="formulaInl" alt="$b$" src="form_132.png"/> gives:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[q = G^{-1} \cdot b\]" src="form_464.png"/>
</p>
<p>The algorithm sets the center of the neighborhood window at this new center <img class="formulaInl" alt="$q$" src="form_457.png"/> and then iterates until the center stays within a set threshold.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Input single-channel, 8-bit or float image. </td></tr>
    <tr><td class="paramname">corners</td><td>Initial coordinates of the input corners and refined coordinates provided for output. </td></tr>
    <tr><td class="paramname">winSize</td><td>Half of the side length of the search window. For example, if winSize=Size(5,5) , then a <img class="formulaInl" alt="$(5*2+1) \times (5*2+1) = 11 \times 11$" src="form_465.png"/> search window is used. </td></tr>
    <tr><td class="paramname">zeroZone</td><td>Half of the size of the dead region in the middle of the search zone over which the summation in the formula below is not done. It is used sometimes to avoid possible singularities of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such a size. </td></tr>
    <tr><td class="paramname">criteria</td><td>Criteria for termination of the iterative process of corner refinement. That is, the process of corner position refinement stops either after criteria.maxCount iterations or when the corner position moves by less than criteria.epsilon on some iteration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga414a47fa161a519aa9943ea3f7890d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga414a47fa161a519aa9943ea3f7890d84">&#9670;&nbsp;</a></span>createLineSegmentDetector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS_W <a class="el" href="structcv_1_1_ptr.html">Ptr</a>&lt; <a class="el" href="classcv_1_1_line_segment_detector.html">LineSegmentDetector</a> &gt; cv::createLineSegmentDetector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_refine</em> = <code><a class="el" href="group__imgproc__feature.html#ggad092a7362b8afb8a905238a41898d98caaf670b2a26f1cc88ae02eaddebc60aab">LSD_REFINE_STD</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_scale</em> = <code>0.8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_sigma_scale</em> = <code>0.6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_quant</em> = <code>2.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_ang_th</em> = <code>22.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_log_eps</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_density_th</em> = <code>0.7</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_n_bins</em> = <code>1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a smart pointer to a <a class="el" href="classcv_1_1_line_segment_detector.html" title="Line segment detector class.">LineSegmentDetector</a> object and initializes it. </p>
<p>The <a class="el" href="classcv_1_1_line_segment_detector.html" title="Line segment detector class.">LineSegmentDetector</a> algorithm is defined using the standard values. Only advanced users may want to edit those, as to tailor it for their own application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_refine</td><td>The way found lines will be refined, see <a class="el" href="group__imgproc__feature.html#gad092a7362b8afb8a905238a41898d98c" title="Variants of Line Segment Detector.">LineSegmentDetectorModes</a> </td></tr>
    <tr><td class="paramname">_scale</td><td>The scale of the image that will be used to find the lines. <a class="el" href="classcv_1_1_range.html" title="Template class specifying a continuous subsequence (slice) of a sequence.">Range</a> (0..1]. </td></tr>
    <tr><td class="paramname">_sigma_scale</td><td>Sigma for Gaussian filter. It is computed as sigma = _sigma_scale/_scale. </td></tr>
    <tr><td class="paramname">_quant</td><td>Bound to the quantization error on the gradient norm. </td></tr>
    <tr><td class="paramname">_ang_th</td><td>Gradient angle tolerance in degrees. </td></tr>
    <tr><td class="paramname">_log_eps</td><td>Detection threshold: -log10(NFA) &gt; log_eps. Used only when advance refinement is chosen. </td></tr>
    <tr><td class="paramname">_density_th</td><td>Minimal density of aligned region points in the enclosing rectangle. </td></tr>
    <tr><td class="paramname">_n_bins</td><td>Number of bins in pseudo-ordering of gradient modulus. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga19e8a8000230fae9736fe837b516a1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19e8a8000230fae9736fe837b516a1d1">&#9670;&nbsp;</a></span>goodFeaturesToTrack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS_W void cv::goodFeaturesToTrack </td>
          <td>(</td>
          <td class="paramtype">InputArray&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1___output_array.html">OutputArray</a>&#160;</td>
          <td class="paramname"><em>corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCorners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qualityLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputArray&#160;</td>
          <td class="paramname"><em>mask</em> = <code>noArray()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSize</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useHarrisDetector</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em> = <code>0.04</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines strong corners on an image. </p>
<p>The function finds the most prominent corners in the image or in the specified image region, as described in <b>[Shi94]</b></p>
<ul>
<li>Function calculates the corner quality measure at every source image pixel using the <a class="el" href="group__imgproc__feature.html#ga363ae1047b9f246e78a82a2862c6cde8" title="Calculates the minimal eigenvalue of gradient matrices for corner detection.">cornerMinEigenVal</a> or <a class="el" href="group__imgproc__feature.html#ga5ce7d0d38d83ef14e335b87c384f39dd" title="Harris corner detector.">cornerHarris</a> .</li>
<li>Function performs a non-maximum suppression (the local maximums in <em>3 x 3</em> neighborhood are retained).</li>
<li>The corners with the minimal eigenvalue less than <img class="formulaInl" alt="$\texttt{qualityLevel} \cdot \max_{x,y} qualityMeasureMap(x,y)$" src="form_466.png"/> are rejected.</li>
<li>The remaining corners are sorted by the quality measure in the descending order.</li>
<li>Function throws away each corner for which there is a stronger corner at a distance less than maxDistance.</li>
</ul>
<p>The function can be used to initialize a point-based tracker of an object.</p>
<dl class="section note"><dt>Note</dt><dd>If the function is called with different values A and B of the parameter qualityLevel , and A &gt; B, the vector of returned corners with qualityLevel=A will be the prefix of the output vector with qualityLevel=B .</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Input 8-bit or floating-point 32-bit, single-channel image. </td></tr>
    <tr><td class="paramname">corners</td><td>Output vector of detected corners. </td></tr>
    <tr><td class="paramname">maxCorners</td><td>Maximum number of corners to return. If there are more corners than are found, the strongest of them is returned. <code>maxCorners &lt;= 0</code> implies that no limit on the maximum is set and all detected corners are returned. </td></tr>
    <tr><td class="paramname">qualityLevel</td><td>Parameter characterizing the minimal accepted quality of image corners. The parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue (see <a class="el" href="group__imgproc__feature.html#ga363ae1047b9f246e78a82a2862c6cde8" title="Calculates the minimal eigenvalue of gradient matrices for corner detection.">cornerMinEigenVal</a> ) or the Harris function response (see <a class="el" href="group__imgproc__feature.html#ga5ce7d0d38d83ef14e335b87c384f39dd" title="Harris corner detector.">cornerHarris</a> ). The corners with the quality measure less than the product are rejected. For example, if the best corner has the quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure less than 15 are rejected. </td></tr>
    <tr><td class="paramname">minDistance</td><td>Minimum possible Euclidean distance between the returned corners. </td></tr>
    <tr><td class="paramname">mask</td><td>Optional region of interest. If the image is not empty (it needs to have the type CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected. </td></tr>
    <tr><td class="paramname">blockSize</td><td>Size of an average block for computing a derivative covariation matrix over each pixel neighborhood. See cornerEigenValsAndVecs . </td></tr>
    <tr><td class="paramname">useHarrisDetector</td><td>Parameter indicating whether to use a Harris detector (see <a class="el" href="group__imgproc__feature.html#ga5ce7d0d38d83ef14e335b87c384f39dd" title="Harris corner detector.">cornerHarris</a>) or <a class="el" href="group__imgproc__feature.html#ga363ae1047b9f246e78a82a2862c6cde8" title="Calculates the minimal eigenvalue of gradient matrices for corner detection.">cornerMinEigenVal</a>. </td></tr>
    <tr><td class="paramname">k</td><td>Free parameter of the Harris detector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__imgproc__feature.html#ga363ae1047b9f246e78a82a2862c6cde8" title="Calculates the minimal eigenvalue of gradient matrices for corner detection.">cornerMinEigenVal</a>, <a class="el" href="group__imgproc__feature.html#ga5ce7d0d38d83ef14e335b87c384f39dd" title="Harris corner detector.">cornerHarris</a>, <a class="el" href="group__video__track.html#gae0e989a246b6c81ee407cb4bc06d0ee8" title="Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyra...">calcOpticalFlowPyrLK</a>, <a class="el" href="group__video__track.html#ga4fe0bae9cfd130fba48efd3eda858b5a" title="Computes an optimal affine transformation between two 2D point sets.">estimateRigidTransform</a>, </dd></dl>

</div>
</div>
<a id="ga87c2c2adf271356817c8636c5ef8a738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87c2c2adf271356817c8636c5ef8a738">&#9670;&nbsp;</a></span>HoughCircles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS_W void cv::HoughCircles </td>
          <td>(</td>
          <td class="paramtype">InputArray&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1___output_array.html">OutputArray</a>&#160;</td>
          <td class="paramname"><em>circles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>param1</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>param2</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minRadius</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxRadius</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds circles in a grayscale image using the Hough transform. </p>
<p>The function finds circles in a grayscale image using a modification of the Hough transform.</p>
<p>Example: : </p><div class="fragment"></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Usually the function detects the centers of circles well. However, it may fail to find correct radii. You can assist to the function by specifying the radius range ( minRadius and maxRadius ) if you know it. Or, you may set maxRadius to a negative number to return centers only without radius search, and find the correct radius using an additional procedure.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>8-bit, single-channel, grayscale input image. </td></tr>
    <tr><td class="paramname">circles</td><td>Output vector of found circles. Each vector is encoded as 3 or 4 element floating-point vector <img class="formulaInl" alt="$(x, y, radius)$" src="form_479.png"/> or <img class="formulaInl" alt="$(x, y, radius, votes)$" src="form_480.png"/> . </td></tr>
    <tr><td class="paramname">method</td><td>Detection method, see <a class="el" href="group__imgproc__feature.html#ga073687a5b96ac7a3ab5802eb5510fe65" title="Variants of a Hough transform.">HoughModes</a>. Currently, the only implemented method is <a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f" title="basically 21HT, described in">HOUGH_GRADIENT</a> </td></tr>
    <tr><td class="paramname">dp</td><td>Inverse ratio of the accumulator resolution to the image resolution. For example, if dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has half as big width and height. </td></tr>
    <tr><td class="paramname">minDist</td><td>Minimum distance between the centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed. </td></tr>
    <tr><td class="paramname">param1</td><td>First method-specific parameter. In case of <a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f" title="basically 21HT, described in">HOUGH_GRADIENT</a> , it is the higher threshold of the two passed to the Canny edge detector (the lower one is twice smaller). </td></tr>
    <tr><td class="paramname">param2</td><td>Second method-specific parameter. In case of <a class="el" href="group__imgproc__feature.html#gga073687a5b96ac7a3ab5802eb5510fe65ac4c5fd257a8ef4decccde6dbfe4e5a0f" title="basically 21HT, described in">HOUGH_GRADIENT</a> , it is the accumulator threshold for the circle centers at the detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first. </td></tr>
    <tr><td class="paramname">minRadius</td><td>Minimum circle radius. </td></tr>
    <tr><td class="paramname">maxRadius</td><td>Maximum circle radius. If &lt;= 0, uses the maximum image dimension. If &lt; 0, returns centers without finding the radius.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__imgproc__shape.html#ga50005270ef5c771e2dde1d002a726145" title="Fits an ellipse around a set of 2D points.">fitEllipse</a>, <a class="el" href="group__imgproc__shape.html#ga1fb5d831897af1598652b27b959fa9ed" title="Finds a circle of the minimum area enclosing a 2D point set.">minEnclosingCircle</a> </dd></dl>

</div>
</div>
<a id="ga0f2f4ef61facc51f7fb249be61801fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f2f4ef61facc51f7fb249be61801fa6">&#9670;&nbsp;</a></span>HoughLines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS_W void cv::HoughLines </td>
          <td>(</td>
          <td class="paramtype">InputArray&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1___output_array.html">OutputArray</a>&#160;</td>
          <td class="paramname"><em>lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>srn</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stn</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_theta</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_theta</em> = <code>CV_PI</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds lines in a binary image using the standard Hough transform. </p>
<p>The function implements the standard or standard multi-scale Hough transform algorithm for line detection. See <a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm">http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm</a> for a good explanation of Hough transform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>8-bit, single-channel binary source image. The image may be modified by the function. </td></tr>
    <tr><td class="paramname">lines</td><td>Output vector of lines. Each line is represented by a 2 or 3 element vector <img class="formulaInl" alt="$(\rho, \theta)$" src="form_467.png"/> or <img class="formulaInl" alt="$(\rho, \theta, \textrm{votes})$" src="form_468.png"/> . <img class="formulaInl" alt="$\rho$" src="form_469.png"/> is the distance from the coordinate origin <img class="formulaInl" alt="$(0,0)$" src="form_470.png"/> (top-left corner of the image). <img class="formulaInl" alt="$\theta$" src="form_471.png"/> is the line rotation angle in radians ( <img class="formulaInl" alt="$0 \sim \textrm{vertical line}, \pi/2 \sim \textrm{horizontal line}$" src="form_472.png"/> ). <img class="formulaInl" alt="$\textrm{votes}$" src="form_473.png"/> is the value of accumulator. </td></tr>
    <tr><td class="paramname">rho</td><td>Distance resolution of the accumulator in pixels. </td></tr>
    <tr><td class="paramname">theta</td><td>Angle resolution of the accumulator in radians. </td></tr>
    <tr><td class="paramname">threshold</td><td><a class="el" href="structcv_1_1_accumulator.html">Accumulator</a> threshold parameter. Only those lines are returned that get enough votes ( <img class="formulaInl" alt="$&gt;\texttt{threshold}$" src="form_474.png"/> ). </td></tr>
    <tr><td class="paramname">srn</td><td>For the multi-scale Hough transform, it is a divisor for the distance resolution rho . The coarse accumulator distance resolution is rho and the accurate accumulator resolution is rho/srn . If both srn=0 and stn=0 , the classical Hough transform is used. Otherwise, both these parameters should be positive. </td></tr>
    <tr><td class="paramname">stn</td><td>For the multi-scale Hough transform, it is a divisor for the distance resolution theta. </td></tr>
    <tr><td class="paramname">min_theta</td><td>For standard and multi-scale Hough transform, minimum angle to check for lines. Must fall between 0 and max_theta. </td></tr>
    <tr><td class="paramname">max_theta</td><td>For standard and multi-scale Hough transform, maximum angle to check for lines. Must fall between min_theta and CV_PI. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga184ca047da5a47af50bc7ff411cc8349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga184ca047da5a47af50bc7ff411cc8349">&#9670;&nbsp;</a></span>HoughLinesP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS_W void cv::HoughLinesP </td>
          <td>(</td>
          <td class="paramtype">InputArray&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1___output_array.html">OutputArray</a>&#160;</td>
          <td class="paramname"><em>lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minLineLength</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxLineGap</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds line segments in a binary image using the probabilistic Hough transform. </p>
<p>The function implements the probabilistic Hough transform algorithm for line detection, described in <b>[Matas00]</b></p>
<p>See the line detection example below: </p><div class="fragment"></div><!-- fragment --><p> This is a sample picture the function parameters have been tuned for:</p>
<img src="pics/building.jpg" alt="image" class="inline"/>
<p>And this is the output of the above program in case of the probabilistic Hough transform:</p>
<img src="pics/houghp.png" alt="image" class="inline"/>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>8-bit, single-channel binary source image. The image may be modified by the function. </td></tr>
    <tr><td class="paramname">lines</td><td>Output vector of lines. Each line is represented by a 4-element vector <img class="formulaInl" alt="$(x_1, y_1, x_2, y_2)$" src="form_475.png"/> , where <img class="formulaInl" alt="$(x_1,y_1)$" src="form_476.png"/> and <img class="formulaInl" alt="$(x_2, y_2)$" src="form_477.png"/> are the ending points of each detected line segment. </td></tr>
    <tr><td class="paramname">rho</td><td>Distance resolution of the accumulator in pixels. </td></tr>
    <tr><td class="paramname">theta</td><td>Angle resolution of the accumulator in radians. </td></tr>
    <tr><td class="paramname">threshold</td><td><a class="el" href="structcv_1_1_accumulator.html">Accumulator</a> threshold parameter. Only those lines are returned that get enough votes ( <img class="formulaInl" alt="$&gt;\texttt{threshold}$" src="form_474.png"/> ). </td></tr>
    <tr><td class="paramname">minLineLength</td><td>Minimum line length. Line segments shorter than that are rejected. </td></tr>
    <tr><td class="paramname">maxLineGap</td><td>Maximum allowed gap between points on the same line to link them.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcv_1_1_line_segment_detector.html" title="Line segment detector class.">LineSegmentDetector</a> </dd></dl>

</div>
</div>
<a id="ga6d43819de9c06b703ecf4475d21936d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d43819de9c06b703ecf4475d21936d4">&#9670;&nbsp;</a></span>HoughLinesPointSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS_W void cv::HoughLinesPointSet </td>
          <td>(</td>
          <td class="paramtype">InputArray&#160;</td>
          <td class="paramname"><em>_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1___output_array.html">OutputArray</a>&#160;</td>
          <td class="paramname"><em>_lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lines_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rho_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta_step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds lines in a set of points using the standard Hough transform. </p>
<p>The function finds lines in a set of points using a modification of the Hough transform. </p><div class="fragment"></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_point</td><td>Input vector of points. Each vector must be encoded as a Point vector <img class="formulaInl" alt="$(x,y)$" src="form_143.png"/>. Type must be CV_32FC2 or CV_32SC2. </td></tr>
    <tr><td class="paramname">_lines</td><td>Output vector of found lines. Each vector is encoded as a vector&lt;Vec3d&gt; <img class="formulaInl" alt="$(votes, rho, theta)$" src="form_478.png"/>. The larger the value of 'votes', the higher the reliability of the Hough line. </td></tr>
    <tr><td class="paramname">lines_max</td><td>Max count of hough lines. </td></tr>
    <tr><td class="paramname">threshold</td><td><a class="el" href="structcv_1_1_accumulator.html">Accumulator</a> threshold parameter. Only those lines are returned that get enough votes ( <img class="formulaInl" alt="$&gt;\texttt{threshold}$" src="form_474.png"/> ) </td></tr>
    <tr><td class="paramname">min_rho</td><td>Minimum Distance value of the accumulator in pixels. </td></tr>
    <tr><td class="paramname">max_rho</td><td>Maximum Distance value of the accumulator in pixels. </td></tr>
    <tr><td class="paramname">rho_step</td><td>Distance resolution of the accumulator in pixels. </td></tr>
    <tr><td class="paramname">min_theta</td><td>Minimum angle value of the accumulator in radians. </td></tr>
    <tr><td class="paramname">max_theta</td><td>Maximum angle value of the accumulator in radians. </td></tr>
    <tr><td class="paramname">theta_step</td><td>Angle resolution of the accumulator in radians. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac6967f1a104b733917d4da9685816cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6967f1a104b733917d4da9685816cf4">&#9670;&nbsp;</a></span>preCornerDetect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CV_EXPORTS_W void cv::preCornerDetect </td>
          <td>(</td>
          <td class="paramtype">InputArray&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1___output_array.html">OutputArray</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>borderType</em> = <code><a class="el" href="group__core__array.html#gga209f2f4869e304c82d07739337eae7c5a43f0bbcfa6f8895c6cc31b5ce0a2aa8a">BORDER_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a feature map for corner detection. </p>
<p>The function calculates the complex spatial derivative-based function of the source image</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\texttt{dst} = (D_x \texttt{src} )^2 \cdot D_{yy} \texttt{src} + (D_y \texttt{src} )^2 \cdot D_{xx} \texttt{src} - 2 D_x \texttt{src} \cdot D_y \texttt{src} \cdot D_{xy} \texttt{src}\]" src="form_451.png"/>
</p>
<p>where <img class="formulaInl" alt="$D_x$" src="form_452.png"/>, <img class="formulaInl" alt="$D_y$" src="form_453.png"/> are the first image derivatives, <img class="formulaInl" alt="$D_{xx}$" src="form_454.png"/>, <img class="formulaInl" alt="$D_{yy}$" src="form_455.png"/> are the second image derivatives, and <img class="formulaInl" alt="$D_{xy}$" src="form_456.png"/> is the mixed derivative.</p>
<p>The corners can be found as local maximums of the functions, as shown below: </p><div class="fragment"><div class="line">Mat corners, dilated_corners;</div><div class="line"><a class="code" href="group__imgproc__feature.html#gac6967f1a104b733917d4da9685816cf4">preCornerDetect</a>(image, corners, 3);</div><div class="line"><span class="comment">// dilation with 3x3 rectangular structuring element</span></div><div class="line"><a class="code" href="group__imgproc__filter.html#gaf226304189a1d4dc4eb9cebb6d25cdec">dilate</a>(corners, dilated_corners, Mat(), 1);</div><div class="line">Mat corner_mask = corners == dilated_corners;</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source single-channel 8-bit of floating-point image. </td></tr>
    <tr><td class="paramname">dst</td><td>Output image that has the type CV_32F and the same size as src . </td></tr>
    <tr><td class="paramname">ksize</td><td>Aperture size of the Sobel . </td></tr>
    <tr><td class="paramname">borderType</td><td>Pixel extrapolation method. See <a class="el" href="group__core__array.html#ga209f2f4869e304c82d07739337eae7c5">BorderTypes</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
