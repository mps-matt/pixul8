<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PixUl8: Universal intrinsics</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PixUl8
   &#160;<span id="projectnumber">3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Universal intrinsics<div class="ingroups"><a class="el" href="group__core.html">Core functionality</a> &raquo; <a class="el" href="group__core__hal.html">Hardware Acceleration Layer</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__core__hal__intrin__impl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin__impl.html">Private implementation helpers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1v__reg.html">cv::v_reg&lt; _Tp, n &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga2323457942fdb195a2b1b6aac3bad605"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga2323457942fdb195a2b1b6aac3bad605">OPENCV_HAL_IMPL_ROTATE_SHIFT_OP</a>(suffix,  opA,  opB)</td></tr>
<tr class="memdesc:ga2323457942fdb195a2b1b6aac3bad605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise shift left.  <a href="#ga2323457942fdb195a2b1b6aac3bad605">More...</a><br /></td></tr>
<tr class="separator:ga2323457942fdb195a2b1b6aac3bad605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2323457942fdb195a2b1b6aac3bad605"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga2323457942fdb195a2b1b6aac3bad605">OPENCV_HAL_IMPL_ROTATE_SHIFT_OP</a>(suffix,  opA,  opB)</td></tr>
<tr class="memdesc:ga2323457942fdb195a2b1b6aac3bad605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise shift left.  <a href="#ga2323457942fdb195a2b1b6aac3bad605">More...</a><br /></td></tr>
<tr class="separator:ga2323457942fdb195a2b1b6aac3bad605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2323457942fdb195a2b1b6aac3bad605"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga2323457942fdb195a2b1b6aac3bad605">OPENCV_HAL_IMPL_ROTATE_SHIFT_OP</a>(suffix,  opA,  opB)</td></tr>
<tr class="memdesc:ga2323457942fdb195a2b1b6aac3bad605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise shift left.  <a href="#ga2323457942fdb195a2b1b6aac3bad605">More...</a><br /></td></tr>
<tr class="separator:ga2323457942fdb195a2b1b6aac3bad605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2323457942fdb195a2b1b6aac3bad605"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga2323457942fdb195a2b1b6aac3bad605">OPENCV_HAL_IMPL_ROTATE_SHIFT_OP</a>(suffix,  opA,  opB)</td></tr>
<tr class="memdesc:ga2323457942fdb195a2b1b6aac3bad605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise shift left.  <a href="#ga2323457942fdb195a2b1b6aac3bad605">More...</a><br /></td></tr>
<tr class="separator:ga2323457942fdb195a2b1b6aac3bad605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2323457942fdb195a2b1b6aac3bad605"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga2323457942fdb195a2b1b6aac3bad605">OPENCV_HAL_IMPL_ROTATE_SHIFT_OP</a>(suffix,  opA,  opB)</td></tr>
<tr class="memdesc:ga2323457942fdb195a2b1b6aac3bad605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise shift left.  <a href="#ga2323457942fdb195a2b1b6aac3bad605">More...</a><br /></td></tr>
<tr class="separator:ga2323457942fdb195a2b1b6aac3bad605"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa3a568f303a60e9ee0db873bfaf92015"><td class="memItemLeft" align="right" valign="top"><a id="gaa3a568f303a60e9ee0db873bfaf92015"></a>
typedef <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; uchar, 16 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gaa3a568f303a60e9ee0db873bfaf92015">cv::v_uint8x16</a></td></tr>
<tr class="memdesc:gaa3a568f303a60e9ee0db873bfaf92015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sixteen 8-bit unsigned integer values. <br /></td></tr>
<tr class="separator:gaa3a568f303a60e9ee0db873bfaf92015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab274058cec2e3881a4e829e0affd2b31"><td class="memItemLeft" align="right" valign="top"><a id="gab274058cec2e3881a4e829e0affd2b31"></a>
typedef <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; schar, 16 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gab274058cec2e3881a4e829e0affd2b31">cv::v_int8x16</a></td></tr>
<tr class="memdesc:gab274058cec2e3881a4e829e0affd2b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sixteen 8-bit signed integer values. <br /></td></tr>
<tr class="separator:gab274058cec2e3881a4e829e0affd2b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga966d320e20d694dfd6ca21c2175d25d7"><td class="memItemLeft" align="right" valign="top"><a id="ga966d320e20d694dfd6ca21c2175d25d7"></a>
typedef <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; ushort, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga966d320e20d694dfd6ca21c2175d25d7">cv::v_uint16x8</a></td></tr>
<tr class="memdesc:ga966d320e20d694dfd6ca21c2175d25d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eight 16-bit unsigned integer values. <br /></td></tr>
<tr class="separator:ga966d320e20d694dfd6ca21c2175d25d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga780a2c041feb13fdc6ae98ca392aa557"><td class="memItemLeft" align="right" valign="top"><a id="ga780a2c041feb13fdc6ae98ca392aa557"></a>
typedef <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; short, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga780a2c041feb13fdc6ae98ca392aa557">cv::v_int16x8</a></td></tr>
<tr class="memdesc:ga780a2c041feb13fdc6ae98ca392aa557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eight 16-bit signed integer values. <br /></td></tr>
<tr class="separator:ga780a2c041feb13fdc6ae98ca392aa557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c925ce71d458526b167f7710c9804f1"><td class="memItemLeft" align="right" valign="top"><a id="ga4c925ce71d458526b167f7710c9804f1"></a>
typedef <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; unsigned, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga4c925ce71d458526b167f7710c9804f1">cv::v_uint32x4</a></td></tr>
<tr class="memdesc:ga4c925ce71d458526b167f7710c9804f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Four 32-bit unsigned integer values. <br /></td></tr>
<tr class="separator:ga4c925ce71d458526b167f7710c9804f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0def4a347f9132829a6adffae8b002c5"><td class="memItemLeft" align="right" valign="top"><a id="ga0def4a347f9132829a6adffae8b002c5"></a>
typedef <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga0def4a347f9132829a6adffae8b002c5">cv::v_int32x4</a></td></tr>
<tr class="memdesc:ga0def4a347f9132829a6adffae8b002c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Four 32-bit signed integer values. <br /></td></tr>
<tr class="separator:ga0def4a347f9132829a6adffae8b002c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddfab95c46aa6df24bc5ef3947bd311b"><td class="memItemLeft" align="right" valign="top"><a id="gaddfab95c46aa6df24bc5ef3947bd311b"></a>
typedef <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">cv::v_float32x4</a></td></tr>
<tr class="memdesc:gaddfab95c46aa6df24bc5ef3947bd311b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Four 32-bit floating point values (single precision) <br /></td></tr>
<tr class="separator:gaddfab95c46aa6df24bc5ef3947bd311b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5b879279ff9e297e12e0e0045f7cdb6"><td class="memItemLeft" align="right" valign="top"><a id="gae5b879279ff9e297e12e0e0045f7cdb6"></a>
typedef <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gae5b879279ff9e297e12e0e0045f7cdb6">cv::v_float64x2</a></td></tr>
<tr class="memdesc:gae5b879279ff9e297e12e0e0045f7cdb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two 64-bit floating point values (double precision) <br /></td></tr>
<tr class="separator:gae5b879279ff9e297e12e0e0045f7cdb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90f59b07f91cd87c17fdc439a6d96b09"><td class="memItemLeft" align="right" valign="top"><a id="ga90f59b07f91cd87c17fdc439a6d96b09"></a>
typedef <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; uint64, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga90f59b07f91cd87c17fdc439a6d96b09">cv::v_uint64x2</a></td></tr>
<tr class="memdesc:ga90f59b07f91cd87c17fdc439a6d96b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two 64-bit unsigned integer values. <br /></td></tr>
<tr class="separator:ga90f59b07f91cd87c17fdc439a6d96b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a9e802163cb5b495a535608f0ab1e35"><td class="memItemLeft" align="right" valign="top"><a id="ga1a9e802163cb5b495a535608f0ab1e35"></a>
typedef <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int64, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga1a9e802163cb5b495a535608f0ab1e35">cv::v_int64x2</a></td></tr>
<tr class="memdesc:ga1a9e802163cb5b495a535608f0ab1e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two 64-bit signed integer values. <br /></td></tr>
<tr class="separator:ga1a9e802163cb5b495a535608f0ab1e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga98d6664ea4069a2011fa0e356be35ccf"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga98d6664ea4069a2011fa0e356be35ccf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga98d6664ea4069a2011fa0e356be35ccf">cv::operator ~</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga98d6664ea4069a2011fa0e356be35ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise AND.  <a href="group__core__hal__intrin.html#ga98d6664ea4069a2011fa0e356be35ccf">More...</a><br /></td></tr>
<tr class="separator:ga98d6664ea4069a2011fa0e356be35ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga278f608463cbdd4d4a45f965e23b9ae5"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga278f608463cbdd4d4a45f965e23b9ae5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__core__hal__intrin.html#ga4c925ce71d458526b167f7710c9804f1">v_uint32x4</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga278f608463cbdd4d4a45f965e23b9ae5">cv::v_popcount</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga278f608463cbdd4d4a45f965e23b9ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the 1 bits in the vector and return 4 values.  <a href="group__core__hal__intrin.html#ga278f608463cbdd4d4a45f965e23b9ae5">More...</a><br /></td></tr>
<tr class="separator:ga278f608463cbdd4d4a45f965e23b9ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae43382fae6719e75b63ecb19726f6b84"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:gae43382fae6719e75b63ecb19726f6b84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gae43382fae6719e75b63ecb19726f6b84">cv::v_not_nan</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt; &amp;a)</td></tr>
<tr class="memdesc:gae43382fae6719e75b63ecb19726f6b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than comparison.  <a href="group__core__hal__intrin.html#gae43382fae6719e75b63ecb19726f6b84">More...</a><br /></td></tr>
<tr class="separator:gae43382fae6719e75b63ecb19726f6b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5070c488a9b0bf89a79a83b21994bfee"><td class="memTemplParams" colspan="2"><a id="ga5070c488a9b0bf89a79a83b21994bfee"></a>
template&lt;int n&gt; </td></tr>
<tr class="memitem:ga5070c488a9b0bf89a79a83b21994bfee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cv::v_not_nan</b> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;a)</td></tr>
<tr class="separator:ga5070c488a9b0bf89a79a83b21994bfee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c726b4b37f3e691d2528b4ee5ff3e9b"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga4c726b4b37f3e691d2528b4ee5ff3e9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::abs_type, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga4c726b4b37f3e691d2528b4ee5ff3e9b">cv::v_absdiff</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b)</td></tr>
<tr class="memdesc:ga4c726b4b37f3e691d2528b4ee5ff3e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add values without saturation.  <a href="group__core__hal__intrin.html#ga4c726b4b37f3e691d2528b4ee5ff3e9b">More...</a><br /></td></tr>
<tr class="separator:ga4c726b4b37f3e691d2528b4ee5ff3e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1767714db3dcadb809e7186824764796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga1767714db3dcadb809e7186824764796">cv::v_absdiff</a> (const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;a, const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;b)</td></tr>
<tr class="separator:ga1767714db3dcadb809e7186824764796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedcb5a63b95a345d4da1d278b4617547"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__hal__intrin.html#gae5b879279ff9e297e12e0e0045f7cdb6">v_float64x2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gaedcb5a63b95a345d4da1d278b4617547">cv::v_absdiff</a> (const <a class="el" href="group__core__hal__intrin.html#gae5b879279ff9e297e12e0e0045f7cdb6">v_float64x2</a> &amp;a, const <a class="el" href="group__core__hal__intrin.html#gae5b879279ff9e297e12e0e0045f7cdb6">v_float64x2</a> &amp;b)</td></tr>
<tr class="separator:gaedcb5a63b95a345d4da1d278b4617547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab20066cd2de62b8691bee711ee4e76f9"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:gab20066cd2de62b8691bee711ee4e76f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gab20066cd2de62b8691bee711ee4e76f9">cv::v_absdiffs</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b)</td></tr>
<tr class="memdesc:gab20066cd2de62b8691bee711ee4e76f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saturating absolute difference.  <a href="group__core__hal__intrin.html#gab20066cd2de62b8691bee711ee4e76f9">More...</a><br /></td></tr>
<tr class="separator:gab20066cd2de62b8691bee711ee4e76f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66050acf0d0658d510929813d8f5eb74"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga66050acf0d0658d510929813d8f5eb74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga66050acf0d0658d510929813d8f5eb74">cv::v_invsqrt</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga66050acf0d0658d510929813d8f5eb74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inversed square root.  <a href="group__core__hal__intrin.html#ga66050acf0d0658d510929813d8f5eb74">More...</a><br /></td></tr>
<tr class="separator:ga66050acf0d0658d510929813d8f5eb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6635a6259cd89761ce4edb164ea2d2b9"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga6635a6259cd89761ce4edb164ea2d2b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga6635a6259cd89761ce4edb164ea2d2b9">cv::v_magnitude</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b)</td></tr>
<tr class="memdesc:ga6635a6259cd89761ce4edb164ea2d2b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magnitude.  <a href="group__core__hal__intrin.html#ga6635a6259cd89761ce4edb164ea2d2b9">More...</a><br /></td></tr>
<tr class="separator:ga6635a6259cd89761ce4edb164ea2d2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga572251b49e39236de0454d5448f0cabe"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga572251b49e39236de0454d5448f0cabe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga572251b49e39236de0454d5448f0cabe">cv::v_sqr_magnitude</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b)</td></tr>
<tr class="memdesc:ga572251b49e39236de0454d5448f0cabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square of the magnitude.  <a href="group__core__hal__intrin.html#ga572251b49e39236de0454d5448f0cabe">More...</a><br /></td></tr>
<tr class="separator:ga572251b49e39236de0454d5448f0cabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5aa4bc7f178b3cc0e6b11781003dd77"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:gaa5aa4bc7f178b3cc0e6b11781003dd77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gaa5aa4bc7f178b3cc0e6b11781003dd77">cv::v_fma</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;c)</td></tr>
<tr class="memdesc:gaa5aa4bc7f178b3cc0e6b11781003dd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and add.  <a href="group__core__hal__intrin.html#gaa5aa4bc7f178b3cc0e6b11781003dd77">More...</a><br /></td></tr>
<tr class="separator:gaa5aa4bc7f178b3cc0e6b11781003dd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga511bd9249c3648039cf7ac6abd98751b"><td class="memTemplParams" colspan="2"><a id="ga511bd9249c3648039cf7ac6abd98751b"></a>
template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga511bd9249c3648039cf7ac6abd98751b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga511bd9249c3648039cf7ac6abd98751b">cv::v_muladd</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;c)</td></tr>
<tr class="memdesc:ga511bd9249c3648039cf7ac6abd98751b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A synonym for v_fma. <br /></td></tr>
<tr class="separator:ga511bd9249c3648039cf7ac6abd98751b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46f313bb7694a20c902c1da740640a86"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga46f313bb7694a20c902c1da740640a86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::w_type, n/2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga46f313bb7694a20c902c1da740640a86">cv::v_dotprod</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b)</td></tr>
<tr class="memdesc:ga46f313bb7694a20c902c1da740640a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product of elements.  <a href="group__core__hal__intrin.html#ga46f313bb7694a20c902c1da740640a86">More...</a><br /></td></tr>
<tr class="separator:ga46f313bb7694a20c902c1da740640a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29aab83572d06b4f0ecfd8aace22233d"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga29aab83572d06b4f0ecfd8aace22233d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::w_type, n/2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga29aab83572d06b4f0ecfd8aace22233d">cv::v_dotprod</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::w_type, n/2 &gt; &amp;c)</td></tr>
<tr class="memdesc:ga29aab83572d06b4f0ecfd8aace22233d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product of elements.  <a href="group__core__hal__intrin.html#ga29aab83572d06b4f0ecfd8aace22233d">More...</a><br /></td></tr>
<tr class="separator:ga29aab83572d06b4f0ecfd8aace22233d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bb510213a964865860cccf6b1ee42bb"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga8bb510213a964865860cccf6b1ee42bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga8bb510213a964865860cccf6b1ee42bb">cv::v_mul_expand</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::w_type, n/2 &gt; &amp;c, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::w_type, n/2 &gt; &amp;d)</td></tr>
<tr class="memdesc:ga8bb510213a964865860cccf6b1ee42bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and expand.  <a href="group__core__hal__intrin.html#ga8bb510213a964865860cccf6b1ee42bb">More...</a><br /></td></tr>
<tr class="separator:ga8bb510213a964865860cccf6b1ee42bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0f63284358630a4670facb86b5e9534"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:gac0f63284358630a4670facb86b5e9534"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gac0f63284358630a4670facb86b5e9534">cv::v_mul_hi</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b)</td></tr>
<tr class="memdesc:gac0f63284358630a4670facb86b5e9534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply and extract high part.  <a href="group__core__hal__intrin.html#gac0f63284358630a4670facb86b5e9534">More...</a><br /></td></tr>
<tr class="separator:gac0f63284358630a4670facb86b5e9534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51066f94e5de1b7905996186d848b5dc"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga51066f94e5de1b7905996186d848b5dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::sum_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga51066f94e5de1b7905996186d848b5dc">cv::v_reduce_sum</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga51066f94e5de1b7905996186d848b5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum packed values.  <a href="group__core__hal__intrin.html#ga51066f94e5de1b7905996186d848b5dc">More...</a><br /></td></tr>
<tr class="separator:ga51066f94e5de1b7905996186d848b5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafec4c6d20a68eba604ec1a480f457f34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gafec4c6d20a68eba604ec1a480f457f34">cv::v_reduce_sum4</a> (const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;a, const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;b, const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;c, const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;d)</td></tr>
<tr class="memdesc:gafec4c6d20a68eba604ec1a480f457f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sums all elements of each input vector, returns the vector of sums.  <a href="group__core__hal__intrin.html#gafec4c6d20a68eba604ec1a480f457f34">More...</a><br /></td></tr>
<tr class="separator:gafec4c6d20a68eba604ec1a480f457f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40a6183aa6144610007fd188a2188039"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga40a6183aa6144610007fd188a2188039"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::abs_type &gt;::sum_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga40a6183aa6144610007fd188a2188039">cv::v_reduce_sad</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b)</td></tr>
<tr class="memdesc:ga40a6183aa6144610007fd188a2188039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum absolute differences of values.  <a href="group__core__hal__intrin.html#ga40a6183aa6144610007fd188a2188039">More...</a><br /></td></tr>
<tr class="separator:ga40a6183aa6144610007fd188a2188039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga191a888185e95f221c8203884e8d66ec"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga191a888185e95f221c8203884e8d66ec"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga191a888185e95f221c8203884e8d66ec">cv::v_signmask</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga191a888185e95f221c8203884e8d66ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get negative values mask.  <a href="group__core__hal__intrin.html#ga191a888185e95f221c8203884e8d66ec">More...</a><br /></td></tr>
<tr class="separator:ga191a888185e95f221c8203884e8d66ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4a93a907f23a3e9028172d09b4822f8"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:gad4a93a907f23a3e9028172d09b4822f8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gad4a93a907f23a3e9028172d09b4822f8">cv::v_check_all</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:gad4a93a907f23a3e9028172d09b4822f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all packed values are less than zero.  <a href="group__core__hal__intrin.html#gad4a93a907f23a3e9028172d09b4822f8">More...</a><br /></td></tr>
<tr class="separator:gad4a93a907f23a3e9028172d09b4822f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03282d0b7c46861f1ecc7329a40634b3"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga03282d0b7c46861f1ecc7329a40634b3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga03282d0b7c46861f1ecc7329a40634b3">cv::v_check_any</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga03282d0b7c46861f1ecc7329a40634b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if any of packed values is less than zero.  <a href="group__core__hal__intrin.html#ga03282d0b7c46861f1ecc7329a40634b3">More...</a><br /></td></tr>
<tr class="separator:ga03282d0b7c46861f1ecc7329a40634b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97f089f6c4606ddba14792d97bbe1b0d"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga97f089f6c4606ddba14792d97bbe1b0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga97f089f6c4606ddba14792d97bbe1b0d">cv::v_select</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;mask, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b)</td></tr>
<tr class="memdesc:ga97f089f6c4606ddba14792d97bbe1b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Per-element select (blend operation)  <a href="group__core__hal__intrin.html#ga97f089f6c4606ddba14792d97bbe1b0d">More...</a><br /></td></tr>
<tr class="separator:ga97f089f6c4606ddba14792d97bbe1b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eff16d8d73c6ce81122b3cd44a99627"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga9eff16d8d73c6ce81122b3cd44a99627"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga9eff16d8d73c6ce81122b3cd44a99627">cv::v_expand</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::w_type, n/2 &gt; &amp;b0, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::w_type, n/2 &gt; &amp;b1)</td></tr>
<tr class="memdesc:ga9eff16d8d73c6ce81122b3cd44a99627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand values to the wider pack type.  <a href="group__core__hal__intrin.html#ga9eff16d8d73c6ce81122b3cd44a99627">More...</a><br /></td></tr>
<tr class="separator:ga9eff16d8d73c6ce81122b3cd44a99627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bee20edc309cbb268408083754e1e14"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga9bee20edc309cbb268408083754e1e14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::w_type, n/2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga9bee20edc309cbb268408083754e1e14">cv::v_expand_low</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga9bee20edc309cbb268408083754e1e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand lower values to the wider pack type.  <a href="group__core__hal__intrin.html#ga9bee20edc309cbb268408083754e1e14">More...</a><br /></td></tr>
<tr class="separator:ga9bee20edc309cbb268408083754e1e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab499a3329ea0f6735a7c0da9258943fd"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:gab499a3329ea0f6735a7c0da9258943fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::w_type, n/2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gab499a3329ea0f6735a7c0da9258943fd">cv::v_expand_high</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:gab499a3329ea0f6735a7c0da9258943fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand higher values to the wider pack type.  <a href="group__core__hal__intrin.html#gab499a3329ea0f6735a7c0da9258943fd">More...</a><br /></td></tr>
<tr class="separator:gab499a3329ea0f6735a7c0da9258943fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19ef6326f6c132d75c62391cedf7c187"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga19ef6326f6c132d75c62391cedf7c187"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga19ef6326f6c132d75c62391cedf7c187">cv::v_zip</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a0, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a1, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b0, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b1)</td></tr>
<tr class="memdesc:ga19ef6326f6c132d75c62391cedf7c187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleave two vectors.  <a href="group__core__hal__intrin.html#ga19ef6326f6c132d75c62391cedf7c187">More...</a><br /></td></tr>
<tr class="separator:ga19ef6326f6c132d75c62391cedf7c187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga418ca8678c1cc9fe07a14d13a4de2c56"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:ga418ca8678c1cc9fe07a14d13a4de2c56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::nlanes128 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga418ca8678c1cc9fe07a14d13a4de2c56">cv::v_load</a> (const _Tp *ptr)</td></tr>
<tr class="memdesc:ga418ca8678c1cc9fe07a14d13a4de2c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load register contents from memory.  <a href="group__core__hal__intrin.html#ga418ca8678c1cc9fe07a14d13a4de2c56">More...</a><br /></td></tr>
<tr class="separator:ga418ca8678c1cc9fe07a14d13a4de2c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa798b76235e5d37e9bdff10e403052a5"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:gaa798b76235e5d37e9bdff10e403052a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::nlanes128 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gaa798b76235e5d37e9bdff10e403052a5">cv::v_load_aligned</a> (const _Tp *ptr)</td></tr>
<tr class="memdesc:gaa798b76235e5d37e9bdff10e403052a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load register contents from memory (aligned)  <a href="group__core__hal__intrin.html#gaa798b76235e5d37e9bdff10e403052a5">More...</a><br /></td></tr>
<tr class="separator:gaa798b76235e5d37e9bdff10e403052a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8311a12f1fff9a41c84092a8f8afe4c"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:gad8311a12f1fff9a41c84092a8f8afe4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::nlanes128 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gad8311a12f1fff9a41c84092a8f8afe4c">cv::v_load_low</a> (const _Tp *ptr)</td></tr>
<tr class="memdesc:gad8311a12f1fff9a41c84092a8f8afe4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load 64-bits of data to lower part (high part is undefined).  <a href="group__core__hal__intrin.html#gad8311a12f1fff9a41c84092a8f8afe4c">More...</a><br /></td></tr>
<tr class="separator:gad8311a12f1fff9a41c84092a8f8afe4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b3dbadf9e2c2f5b1bb4827200bc5912"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:ga4b3dbadf9e2c2f5b1bb4827200bc5912"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::nlanes128 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga4b3dbadf9e2c2f5b1bb4827200bc5912">cv::v_load_halves</a> (const _Tp *loptr, const _Tp *hiptr)</td></tr>
<tr class="memdesc:ga4b3dbadf9e2c2f5b1bb4827200bc5912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load register contents from two memory blocks.  <a href="group__core__hal__intrin.html#ga4b3dbadf9e2c2f5b1bb4827200bc5912">More...</a><br /></td></tr>
<tr class="separator:ga4b3dbadf9e2c2f5b1bb4827200bc5912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf31e8453b851d1017dd3736bb18e5031"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:gaf31e8453b851d1017dd3736bb18e5031"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::w_type, <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::nlanes128/2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gaf31e8453b851d1017dd3736bb18e5031">cv::v_load_expand</a> (const _Tp *ptr)</td></tr>
<tr class="memdesc:gaf31e8453b851d1017dd3736bb18e5031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load register contents from memory with double expand.  <a href="group__core__hal__intrin.html#gaf31e8453b851d1017dd3736bb18e5031">More...</a><br /></td></tr>
<tr class="separator:gaf31e8453b851d1017dd3736bb18e5031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3505ff70e83d0809045ef1dcd91f927"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:gae3505ff70e83d0809045ef1dcd91f927"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::q_type, <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::nlanes128/4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gae3505ff70e83d0809045ef1dcd91f927">cv::v_load_expand_q</a> (const _Tp *ptr)</td></tr>
<tr class="memdesc:gae3505ff70e83d0809045ef1dcd91f927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load register contents from memory with quad expand.  <a href="group__core__hal__intrin.html#gae3505ff70e83d0809045ef1dcd91f927">More...</a><br /></td></tr>
<tr class="separator:gae3505ff70e83d0809045ef1dcd91f927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd8e859406c66bb5b7d901473265119b"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:gafd8e859406c66bb5b7d901473265119b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gafd8e859406c66bb5b7d901473265119b">cv::v_load_deinterleave</a> (const _Tp *ptr, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b)</td></tr>
<tr class="memdesc:gafd8e859406c66bb5b7d901473265119b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and deinterleave (2 channels)  <a href="group__core__hal__intrin.html#gafd8e859406c66bb5b7d901473265119b">More...</a><br /></td></tr>
<tr class="separator:gafd8e859406c66bb5b7d901473265119b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab364b341969494d47e6a1b173fc46658"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:gab364b341969494d47e6a1b173fc46658"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gab364b341969494d47e6a1b173fc46658">cv::v_load_deinterleave</a> (const _Tp *ptr, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;c)</td></tr>
<tr class="memdesc:gab364b341969494d47e6a1b173fc46658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and deinterleave (3 channels)  <a href="group__core__hal__intrin.html#gab364b341969494d47e6a1b173fc46658">More...</a><br /></td></tr>
<tr class="separator:gab364b341969494d47e6a1b173fc46658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f1f0d87d6210547bb125fd349a10e5d"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga7f1f0d87d6210547bb125fd349a10e5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga7f1f0d87d6210547bb125fd349a10e5d">cv::v_load_deinterleave</a> (const _Tp *ptr, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;c, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;d)</td></tr>
<tr class="memdesc:ga7f1f0d87d6210547bb125fd349a10e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load and deinterleave (4 channels)  <a href="group__core__hal__intrin.html#ga7f1f0d87d6210547bb125fd349a10e5d">More...</a><br /></td></tr>
<tr class="separator:ga7f1f0d87d6210547bb125fd349a10e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa809d0656c94b2bb24b9be06295f037e"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:gaa809d0656c94b2bb24b9be06295f037e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gaa809d0656c94b2bb24b9be06295f037e">cv::v_store_interleave</a> (_Tp *ptr, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b, hal::StoreMode=hal::STORE_UNALIGNED)</td></tr>
<tr class="memdesc:gaa809d0656c94b2bb24b9be06295f037e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleave and store (2 channels)  <a href="group__core__hal__intrin.html#gaa809d0656c94b2bb24b9be06295f037e">More...</a><br /></td></tr>
<tr class="separator:gaa809d0656c94b2bb24b9be06295f037e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga642197a56fa99a60b9caeee19fed1a61"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga642197a56fa99a60b9caeee19fed1a61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga642197a56fa99a60b9caeee19fed1a61">cv::v_store_interleave</a> (_Tp *ptr, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;c, hal::StoreMode=hal::STORE_UNALIGNED)</td></tr>
<tr class="memdesc:ga642197a56fa99a60b9caeee19fed1a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleave and store (3 channels)  <a href="group__core__hal__intrin.html#ga642197a56fa99a60b9caeee19fed1a61">More...</a><br /></td></tr>
<tr class="separator:ga642197a56fa99a60b9caeee19fed1a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f28a67e567d9f1fee7a16d264fcaa5d"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga7f28a67e567d9f1fee7a16d264fcaa5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga7f28a67e567d9f1fee7a16d264fcaa5d">cv::v_store_interleave</a> (_Tp *ptr, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;c, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;d, hal::StoreMode=hal::STORE_UNALIGNED)</td></tr>
<tr class="memdesc:ga7f28a67e567d9f1fee7a16d264fcaa5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleave and store (4 channels)  <a href="group__core__hal__intrin.html#ga7f28a67e567d9f1fee7a16d264fcaa5d">More...</a><br /></td></tr>
<tr class="separator:ga7f28a67e567d9f1fee7a16d264fcaa5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga275dfa9c8935f5e9a1031121cde460f4"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga275dfa9c8935f5e9a1031121cde460f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga275dfa9c8935f5e9a1031121cde460f4">cv::v_store</a> (_Tp *ptr, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga275dfa9c8935f5e9a1031121cde460f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store data to memory.  <a href="group__core__hal__intrin.html#ga275dfa9c8935f5e9a1031121cde460f4">More...</a><br /></td></tr>
<tr class="separator:ga275dfa9c8935f5e9a1031121cde460f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cb662d09e37eae1e73043badee69612"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga3cb662d09e37eae1e73043badee69612"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga3cb662d09e37eae1e73043badee69612">cv::v_store_low</a> (_Tp *ptr, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga3cb662d09e37eae1e73043badee69612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store data to memory (lower half)  <a href="group__core__hal__intrin.html#ga3cb662d09e37eae1e73043badee69612">More...</a><br /></td></tr>
<tr class="separator:ga3cb662d09e37eae1e73043badee69612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1665beb52f3824499d3b6b1203890ada"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga1665beb52f3824499d3b6b1203890ada"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga1665beb52f3824499d3b6b1203890ada">cv::v_store_high</a> (_Tp *ptr, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga1665beb52f3824499d3b6b1203890ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store data to memory (higher half)  <a href="group__core__hal__intrin.html#ga1665beb52f3824499d3b6b1203890ada">More...</a><br /></td></tr>
<tr class="separator:ga1665beb52f3824499d3b6b1203890ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2733377e1bc373657d0e203028c74fc"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:gaf2733377e1bc373657d0e203028c74fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gaf2733377e1bc373657d0e203028c74fc">cv::v_store_aligned</a> (_Tp *ptr, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="memdesc:gaf2733377e1bc373657d0e203028c74fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store data to memory (aligned)  <a href="group__core__hal__intrin.html#gaf2733377e1bc373657d0e203028c74fc">More...</a><br /></td></tr>
<tr class="separator:gaf2733377e1bc373657d0e203028c74fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53aa8640c7a552a45ab2233c2f974e83"><td class="memTemplParams" colspan="2"><a id="ga53aa8640c7a552a45ab2233c2f974e83"></a>
template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga53aa8640c7a552a45ab2233c2f974e83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cv::v_store_aligned_nocache</b> (_Tp *ptr, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a)</td></tr>
<tr class="separator:ga53aa8640c7a552a45ab2233c2f974e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36c04e381bb5c8d16f889dfcc21e902d"><td class="memTemplParams" colspan="2"><a id="ga36c04e381bb5c8d16f889dfcc21e902d"></a>
template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga36c04e381bb5c8d16f889dfcc21e902d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cv::v_store_aligned</b> (_Tp *ptr, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, hal::StoreMode)</td></tr>
<tr class="separator:ga36c04e381bb5c8d16f889dfcc21e902d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad083778ca6d5d290b698a963eef18863"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:gad083778ca6d5d290b698a963eef18863"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gad083778ca6d5d290b698a963eef18863">cv::v_combine_low</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b)</td></tr>
<tr class="memdesc:gad083778ca6d5d290b698a963eef18863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine vector from first elements of two vectors.  <a href="group__core__hal__intrin.html#gad083778ca6d5d290b698a963eef18863">More...</a><br /></td></tr>
<tr class="separator:gad083778ca6d5d290b698a963eef18863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07992fc8a3a9af17eb8fc4460b6e178e"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga07992fc8a3a9af17eb8fc4460b6e178e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga07992fc8a3a9af17eb8fc4460b6e178e">cv::v_combine_high</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b)</td></tr>
<tr class="memdesc:ga07992fc8a3a9af17eb8fc4460b6e178e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine vector from last elements of two vectors.  <a href="group__core__hal__intrin.html#ga07992fc8a3a9af17eb8fc4460b6e178e">More...</a><br /></td></tr>
<tr class="separator:ga07992fc8a3a9af17eb8fc4460b6e178e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75a3cb5bb426fc37d9ed2f10e8706997"><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr class="memitem:ga75a3cb5bb426fc37d9ed2f10e8706997"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga75a3cb5bb426fc37d9ed2f10e8706997">cv::v_recombine</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;low, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;high)</td></tr>
<tr class="memdesc:ga75a3cb5bb426fc37d9ed2f10e8706997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine two vectors from lower and higher parts of two other vectors.  <a href="group__core__hal__intrin.html#ga75a3cb5bb426fc37d9ed2f10e8706997">More...</a><br /></td></tr>
<tr class="separator:ga75a3cb5bb426fc37d9ed2f10e8706997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd8010dbc3fd9f58d0bcc78b09bb04be"><td class="memTemplParams" colspan="2">template&lt;int s, typename _Tp , int n&gt; </td></tr>
<tr class="memitem:gafd8010dbc3fd9f58d0bcc78b09bb04be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gafd8010dbc3fd9f58d0bcc78b09bb04be">cv::v_extract</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;b)</td></tr>
<tr class="memdesc:gafd8010dbc3fd9f58d0bcc78b09bb04be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector extract.  <a href="group__core__hal__intrin.html#gafd8010dbc3fd9f58d0bcc78b09bb04be">More...</a><br /></td></tr>
<tr class="separator:gafd8010dbc3fd9f58d0bcc78b09bb04be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08a1619cc35c793cf4e985bf814aa7b3"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:ga08a1619cc35c793cf4e985bf814aa7b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga08a1619cc35c793cf4e985bf814aa7b3">cv::v_round</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga08a1619cc35c793cf4e985bf814aa7b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round.  <a href="group__core__hal__intrin.html#ga08a1619cc35c793cf4e985bf814aa7b3">More...</a><br /></td></tr>
<tr class="separator:ga08a1619cc35c793cf4e985bf814aa7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab76c02016dd0346ae33faf583f0c231b"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:gab76c02016dd0346ae33faf583f0c231b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n *2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gab76c02016dd0346ae33faf583f0c231b">cv::v_round</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;b)</td></tr>
<tr class="separator:gab76c02016dd0346ae33faf583f0c231b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40660ffb65da4ec0ffcb13d3a8568e71"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:ga40660ffb65da4ec0ffcb13d3a8568e71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga40660ffb65da4ec0ffcb13d3a8568e71">cv::v_floor</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga40660ffb65da4ec0ffcb13d3a8568e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floor.  <a href="group__core__hal__intrin.html#ga40660ffb65da4ec0ffcb13d3a8568e71">More...</a><br /></td></tr>
<tr class="separator:ga40660ffb65da4ec0ffcb13d3a8568e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ae26ec587729aa1e9d548a1abc0e4d1"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:ga2ae26ec587729aa1e9d548a1abc0e4d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga2ae26ec587729aa1e9d548a1abc0e4d1">cv::v_ceil</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga2ae26ec587729aa1e9d548a1abc0e4d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ceil.  <a href="group__core__hal__intrin.html#ga2ae26ec587729aa1e9d548a1abc0e4d1">More...</a><br /></td></tr>
<tr class="separator:ga2ae26ec587729aa1e9d548a1abc0e4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga572e0c84eceb69db61eeee0a189b4cad"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:ga572e0c84eceb69db61eeee0a189b4cad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga572e0c84eceb69db61eeee0a189b4cad">cv::v_trunc</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt; &amp;a)</td></tr>
<tr class="memdesc:ga572e0c84eceb69db61eeee0a189b4cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trunc.  <a href="group__core__hal__intrin.html#ga572e0c84eceb69db61eeee0a189b4cad">More...</a><br /></td></tr>
<tr class="separator:ga572e0c84eceb69db61eeee0a189b4cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50363564443765f12ecce74cf6cab1f8"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:ga50363564443765f12ecce74cf6cab1f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n *2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga50363564443765f12ecce74cf6cab1f8">cv::v_round</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;a)</td></tr>
<tr class="separator:ga50363564443765f12ecce74cf6cab1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c2b8152bc9dfee7f4ed37b4a35c45e6"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:ga5c2b8152bc9dfee7f4ed37b4a35c45e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n *2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga5c2b8152bc9dfee7f4ed37b4a35c45e6">cv::v_floor</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;a)</td></tr>
<tr class="separator:ga5c2b8152bc9dfee7f4ed37b4a35c45e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11eb63b0bee6d4da54ccf2654fd1617a"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:ga11eb63b0bee6d4da54ccf2654fd1617a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n *2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga11eb63b0bee6d4da54ccf2654fd1617a">cv::v_ceil</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;a)</td></tr>
<tr class="separator:ga11eb63b0bee6d4da54ccf2654fd1617a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eb1af43eca988202b5374a5486cfd09"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:ga5eb1af43eca988202b5374a5486cfd09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n *2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga5eb1af43eca988202b5374a5486cfd09">cv::v_trunc</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;a)</td></tr>
<tr class="separator:ga5eb1af43eca988202b5374a5486cfd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2782cdc9394130b4ebe3d62ff6964c7"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:gad2782cdc9394130b4ebe3d62ff6964c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gad2782cdc9394130b4ebe3d62ff6964c7">cv::v_cvt_f32</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n &gt; &amp;a)</td></tr>
<tr class="memdesc:gad2782cdc9394130b4ebe3d62ff6964c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to float.  <a href="group__core__hal__intrin.html#gad2782cdc9394130b4ebe3d62ff6964c7">More...</a><br /></td></tr>
<tr class="separator:gad2782cdc9394130b4ebe3d62ff6964c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78f588b3b5975cb74156663b310f4c79"><td class="memTemplParams" colspan="2"><a id="ga78f588b3b5975cb74156663b310f4c79"></a>
template&lt;int n&gt; </td></tr>
<tr class="memitem:ga78f588b3b5975cb74156663b310f4c79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n *2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cv::v_cvt_f32</b> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;a, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;b)</td></tr>
<tr class="separator:ga78f588b3b5975cb74156663b310f4c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3a9fce8f3c4ec707f44580f568ae7ae"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:gaf3a9fce8f3c4ec707f44580f568ae7ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gaf3a9fce8f3c4ec707f44580f568ae7ae">cv::v_cvt_f64</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n *2 &gt; &amp;a)</td></tr>
<tr class="memdesc:gaf3a9fce8f3c4ec707f44580f568ae7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to double.  <a href="group__core__hal__intrin.html#gaf3a9fce8f3c4ec707f44580f568ae7ae">More...</a><br /></td></tr>
<tr class="separator:gaf3a9fce8f3c4ec707f44580f568ae7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05e90423771387353c348a19def2edb5"><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr class="memitem:ga05e90423771387353c348a19def2edb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga05e90423771387353c348a19def2edb5">cv::v_cvt_f64</a> (const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n *2 &gt; &amp;a)</td></tr>
<tr class="memdesc:ga05e90423771387353c348a19def2edb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to double.  <a href="group__core__hal__intrin.html#ga05e90423771387353c348a19def2edb5">More...</a><br /></td></tr>
<tr class="separator:ga05e90423771387353c348a19def2edb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22e72147dc8da30646badc56c25c8bde"><td class="memTemplParams" colspan="2"><a id="ga22e72147dc8da30646badc56c25c8bde"></a>
template&lt;int n&gt; </td></tr>
<tr class="memitem:ga22e72147dc8da30646badc56c25c8bde"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cv::v_lut</b> (const int *tab, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n &gt; &amp;idx)</td></tr>
<tr class="separator:ga22e72147dc8da30646badc56c25c8bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga865d8608427c4ddc14d2d26659a0c69d"><td class="memTemplParams" colspan="2"><a id="ga865d8608427c4ddc14d2d26659a0c69d"></a>
template&lt;int n&gt; </td></tr>
<tr class="memitem:ga865d8608427c4ddc14d2d26659a0c69d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cv::v_lut</b> (const float *tab, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n &gt; &amp;idx)</td></tr>
<tr class="separator:ga865d8608427c4ddc14d2d26659a0c69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga135a397fcb68077f1def5438c97a2a78"><td class="memTemplParams" colspan="2"><a id="ga135a397fcb68077f1def5438c97a2a78"></a>
template&lt;int n&gt; </td></tr>
<tr class="memitem:ga135a397fcb68077f1def5438c97a2a78"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cv::v_lut</b> (const double *tab, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n *2 &gt; &amp;idx)</td></tr>
<tr class="separator:ga135a397fcb68077f1def5438c97a2a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9d7072e2fed05b076a450a03fa41d3f"><td class="memTemplParams" colspan="2"><a id="gaa9d7072e2fed05b076a450a03fa41d3f"></a>
template&lt;int n&gt; </td></tr>
<tr class="memitem:gaa9d7072e2fed05b076a450a03fa41d3f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cv::v_lut_deinterleave</b> (const float *tab, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n &gt; &amp;idx, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt; &amp;x, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt; &amp;y)</td></tr>
<tr class="separator:gaa9d7072e2fed05b076a450a03fa41d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad08aac715b83d26af9f8d2911f2f8c39"><td class="memTemplParams" colspan="2"><a id="gad08aac715b83d26af9f8d2911f2f8c39"></a>
template&lt;int n&gt; </td></tr>
<tr class="memitem:gad08aac715b83d26af9f8d2911f2f8c39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cv::v_lut_deinterleave</b> (const double *tab, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n *2 &gt; &amp;idx, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;x, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;y)</td></tr>
<tr class="separator:gad08aac715b83d26af9f8d2911f2f8c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8bdcd643d22a9fc9c3f0ed202535928"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:gaf8bdcd643d22a9fc9c3f0ed202535928"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gaf8bdcd643d22a9fc9c3f0ed202535928">cv::v_transpose4x4</a> (<a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;a0, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;a1, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;a2, const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;a3, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;b0, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;b1, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;b2, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;b3)</td></tr>
<tr class="memdesc:gaf8bdcd643d22a9fc9c3f0ed202535928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose 4x4 matrix.  <a href="group__core__hal__intrin.html#gaf8bdcd643d22a9fc9c3f0ed202535928">More...</a><br /></td></tr>
<tr class="separator:gaf8bdcd643d22a9fc9c3f0ed202535928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f53754058cbcd76b98db8525cefe869"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga4f53754058cbcd76b98db8525cefe869">cv::v_matmul</a> (const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;v, const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;m0, const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;m1, const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;m2, const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;m3)</td></tr>
<tr class="memdesc:ga4f53754058cbcd76b98db8525cefe869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiplication.  <a href="group__core__hal__intrin.html#ga4f53754058cbcd76b98db8525cefe869">More...</a><br /></td></tr>
<tr class="separator:ga4f53754058cbcd76b98db8525cefe869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a36df5c9313f6132192c0b9ae2aefb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga1a36df5c9313f6132192c0b9ae2aefb0">cv::v_matmuladd</a> (const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;v, const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;m0, const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;m1, const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;m2, const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;m3)</td></tr>
<tr class="memdesc:ga1a36df5c9313f6132192c0b9ae2aefb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiplication and add.  <a href="group__core__hal__intrin.html#ga1a36df5c9313f6132192c0b9ae2aefb0">More...</a><br /></td></tr>
<tr class="separator:ga1a36df5c9313f6132192c0b9ae2aefb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f6b137e761fff0a5c0484b9537cc353"><td class="memItemLeft" align="right" valign="top"><a id="ga3f6b137e761fff0a5c0484b9537cc353"></a>
<a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; float &gt;::nlanes128 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>cv::v_load_expand</b> (const float16_t *ptr)</td></tr>
<tr class="separator:ga3f6b137e761fff0a5c0484b9537cc353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11776e8e983fa91c32648dfaa995021b"><td class="memItemLeft" align="right" valign="top"><a id="ga11776e8e983fa91c32648dfaa995021b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cv::v_pack_store</b> (float16_t *ptr, <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; float &gt;::nlanes128 &gt; &amp;v)</td></tr>
<tr class="separator:ga11776e8e983fa91c32648dfaa995021b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa24f949c3930df676514d3f06f114cb7"><td class="memItemLeft" align="right" valign="top"><a id="gaa24f949c3930df676514d3f06f114cb7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cv::v_cleanup</b> ()</td></tr>
<tr class="separator:gaa24f949c3930df676514d3f06f114cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Pack boolean values</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp515ab880517fbf1ca21fc0e2ba62ba5a"></a>Pack boolean values from multiple vectors to one unsigned 8-bit integer vector</p>
<dl class="section note"><dt>Note</dt><dd>Must provide valid boolean values to guarantee same result for all architectures. </dd></dl>
</td></tr>
<tr class="memitem:ga4183265b6f133d0a8a8b6598cfa61fe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__hal__intrin.html#gaa3a568f303a60e9ee0db873bfaf92015">v_uint8x16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#ga4183265b6f133d0a8a8b6598cfa61fe8">cv::v_pack_b</a> (const <a class="el" href="group__core__hal__intrin.html#ga966d320e20d694dfd6ca21c2175d25d7">v_uint16x8</a> &amp;a, const <a class="el" href="group__core__hal__intrin.html#ga966d320e20d694dfd6ca21c2175d25d7">v_uint16x8</a> &amp;b)</td></tr>
<tr class="memdesc:ga4183265b6f133d0a8a8b6598cfa61fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">! For 16-bit boolean values  <a href="group__core__hal__intrin.html#ga4183265b6f133d0a8a8b6598cfa61fe8">More...</a><br /></td></tr>
<tr class="separator:ga4183265b6f133d0a8a8b6598cfa61fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7e6ed6c7c6d0cf64f295fd8b86c08f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__hal__intrin.html#gaa3a568f303a60e9ee0db873bfaf92015">v_uint8x16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gad7e6ed6c7c6d0cf64f295fd8b86c08f8">cv::v_pack_b</a> (const <a class="el" href="group__core__hal__intrin.html#ga4c925ce71d458526b167f7710c9804f1">v_uint32x4</a> &amp;a, const <a class="el" href="group__core__hal__intrin.html#ga4c925ce71d458526b167f7710c9804f1">v_uint32x4</a> &amp;b, const <a class="el" href="group__core__hal__intrin.html#ga4c925ce71d458526b167f7710c9804f1">v_uint32x4</a> &amp;c, const <a class="el" href="group__core__hal__intrin.html#ga4c925ce71d458526b167f7710c9804f1">v_uint32x4</a> &amp;d)</td></tr>
<tr class="separator:gad7e6ed6c7c6d0cf64f295fd8b86c08f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4f237e5e9fd54dfef2590bb4ee686a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__hal__intrin.html#gaa3a568f303a60e9ee0db873bfaf92015">v_uint8x16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__hal__intrin.html#gad4f237e5e9fd54dfef2590bb4ee686a2">cv::v_pack_b</a> (const <a class="el" href="group__core__hal__intrin.html#ga90f59b07f91cd87c17fdc439a6d96b09">v_uint64x2</a> &amp;a, const <a class="el" href="group__core__hal__intrin.html#ga90f59b07f91cd87c17fdc439a6d96b09">v_uint64x2</a> &amp;b, const <a class="el" href="group__core__hal__intrin.html#ga90f59b07f91cd87c17fdc439a6d96b09">v_uint64x2</a> &amp;c, const <a class="el" href="group__core__hal__intrin.html#ga90f59b07f91cd87c17fdc439a6d96b09">v_uint64x2</a> &amp;d, const <a class="el" href="group__core__hal__intrin.html#ga90f59b07f91cd87c17fdc439a6d96b09">v_uint64x2</a> &amp;e, const <a class="el" href="group__core__hal__intrin.html#ga90f59b07f91cd87c17fdc439a6d96b09">v_uint64x2</a> &amp;f, const <a class="el" href="group__core__hal__intrin.html#ga90f59b07f91cd87c17fdc439a6d96b09">v_uint64x2</a> &amp;g, const <a class="el" href="group__core__hal__intrin.html#ga90f59b07f91cd87c17fdc439a6d96b09">v_uint64x2</a> &amp;h)</td></tr>
<tr class="separator:gad4f237e5e9fd54dfef2590bb4ee686a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>"Universal intrinsics" is a types and functions set intended to simplify vectorization of code on different platforms. Currently there are two supported SIMD extensions: <b>SSE/SSE2</b> on x86 architectures and <b>NEON</b> on ARM architectures, both allow working with 128 bit registers containing packed values of different types. In case when there is no SIMD extension available during compilation, fallback C++ implementation of intrinsics will be chosen and code will work as expected although it could be slower.</p>
<h3>Types</h3>
<p>There are several types representing 128-bit register as a vector of packed values, each type is implemented as a structure based on a one SIMD register.</p>
<ul>
<li><a class="el" href="group__core__hal__intrin.html#gaa3a568f303a60e9ee0db873bfaf92015" title="Sixteen 8-bit unsigned integer values.">cv::v_uint8x16</a> and <a class="el" href="group__core__hal__intrin.html#gab274058cec2e3881a4e829e0affd2b31" title="Sixteen 8-bit signed integer values.">cv::v_int8x16</a>: sixteen 8-bit integer values (unsigned/signed) - char</li>
<li><a class="el" href="group__core__hal__intrin.html#ga966d320e20d694dfd6ca21c2175d25d7" title="Eight 16-bit unsigned integer values.">cv::v_uint16x8</a> and <a class="el" href="group__core__hal__intrin.html#ga780a2c041feb13fdc6ae98ca392aa557" title="Eight 16-bit signed integer values.">cv::v_int16x8</a>: eight 16-bit integer values (unsigned/signed) - short</li>
<li><a class="el" href="group__core__hal__intrin.html#ga4c925ce71d458526b167f7710c9804f1" title="Four 32-bit unsigned integer values.">cv::v_uint32x4</a> and <a class="el" href="group__core__hal__intrin.html#ga0def4a347f9132829a6adffae8b002c5" title="Four 32-bit signed integer values.">cv::v_int32x4</a>: four 32-bit integer values (unsgined/signed) - int</li>
<li><a class="el" href="group__core__hal__intrin.html#ga90f59b07f91cd87c17fdc439a6d96b09" title="Two 64-bit unsigned integer values.">cv::v_uint64x2</a> and <a class="el" href="group__core__hal__intrin.html#ga1a9e802163cb5b495a535608f0ab1e35" title="Two 64-bit signed integer values.">cv::v_int64x2</a>: two 64-bit integer values (unsigned/signed) - int64</li>
<li><a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b" title="Four 32-bit floating point values (single precision)">cv::v_float32x4</a>: four 32-bit floating point values (signed) - float</li>
<li><a class="el" href="group__core__hal__intrin.html#gae5b879279ff9e297e12e0e0045f7cdb6" title="Two 64-bit floating point values (double precision)">cv::v_float64x2</a>: two 64-bit floating point valies (signed) - double</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__core__hal__intrin.html#gae5b879279ff9e297e12e0e0045f7cdb6" title="Two 64-bit floating point values (double precision)">cv::v_float64x2</a> is not implemented in NEON variant, if you want to use this type, don't forget to check the CV_SIMD128_64F preprocessor definition: <div class="fragment"><div class="line"><span class="preprocessor">#if CV_SIMD128_64F</span></div><div class="line"><span class="comment">//...</span></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --></dd></dl>
<h3>Load and store operations</h3>
<p>These operations allow to set contents of the register explicitly or by loading it from some memory block and to save contents of the register to memory block.</p>
<ul>
<li>Constructors: <a class="el" href="structcv_1_1v__reg.html#a9791853618ca6b65cc0868de0f117728">from memory</a>, <a class="el" href="structcv_1_1v__reg.html#adcf59996aa232fa9b65dc3ce295d5183">from two values</a>, ...</li>
<li>Other create methods: v_setall_s8, v_setall_u8, ..., v_setzero_u8, v_setzero_s8, ...</li>
<li>Memory operations: <a class="el" href="group__core__hal__intrin.html#ga418ca8678c1cc9fe07a14d13a4de2c56">v_load</a>, <a class="el" href="group__core__hal__intrin.html#gaa798b76235e5d37e9bdff10e403052a5">v_load_aligned</a>, <a class="el" href="group__core__hal__intrin.html#gad8311a12f1fff9a41c84092a8f8afe4c">v_load_low</a>, <a class="el" href="group__core__hal__intrin.html#ga4b3dbadf9e2c2f5b1bb4827200bc5912">v_load_halves</a>, <a class="el" href="group__core__hal__intrin.html#ga275dfa9c8935f5e9a1031121cde460f4">v_store</a>, <a class="el" href="group__core__hal__intrin.html#gaf2733377e1bc373657d0e203028c74fc">v_store_aligned</a>, <a class="el" href="group__core__hal__intrin.html#ga1665beb52f3824499d3b6b1203890ada">v_store_high</a>, <a class="el" href="group__core__hal__intrin.html#ga3cb662d09e37eae1e73043badee69612">v_store_low</a></li>
</ul>
<h3>Value reordering</h3>
<p>These operations allow to reorder or recombine elements in one or multiple vectors.</p>
<ul>
<li>Interleave, deinterleave (2, 3 and 4 channels): <a class="el" href="group__core__hal__intrin.html#gafd8e859406c66bb5b7d901473265119b">v_load_deinterleave</a>, <a class="el" href="group__core__hal__intrin.html#gaa809d0656c94b2bb24b9be06295f037e">v_store_interleave</a></li>
<li>Expand: <a class="el" href="group__core__hal__intrin.html#gaf31e8453b851d1017dd3736bb18e5031">v_load_expand</a>, <a class="el" href="group__core__hal__intrin.html#gae3505ff70e83d0809045ef1dcd91f927">v_load_expand_q</a>, <a class="el" href="group__core__hal__intrin.html#ga9eff16d8d73c6ce81122b3cd44a99627">v_expand</a>, <a class="el" href="group__core__hal__intrin.html#ga9bee20edc309cbb268408083754e1e14">v_expand_low</a>, <a class="el" href="group__core__hal__intrin.html#gab499a3329ea0f6735a7c0da9258943fd">v_expand_high</a></li>
<li>Pack: v_pack, v_pack_u, <a class="el" href="group__core__hal__intrin.html#ga4183265b6f133d0a8a8b6598cfa61fe8">v_pack_b</a>, v_rshr_pack, v_rshr_pack_u, v_pack_store, v_pack_u_store, v_rshr_pack_store, v_rshr_pack_u_store</li>
<li>Recombine: <a class="el" href="group__core__hal__intrin.html#ga19ef6326f6c132d75c62391cedf7c187">v_zip</a>, <a class="el" href="group__core__hal__intrin.html#ga75a3cb5bb426fc37d9ed2f10e8706997">v_recombine</a>, <a class="el" href="group__core__hal__intrin.html#gad083778ca6d5d290b698a963eef18863">v_combine_low</a>, <a class="el" href="group__core__hal__intrin.html#ga07992fc8a3a9af17eb8fc4460b6e178e">v_combine_high</a></li>
<li>Extract: <a class="el" href="group__core__hal__intrin.html#gafd8010dbc3fd9f58d0bcc78b09bb04be">v_extract</a></li>
</ul>
<h3>Arithmetic, bitwise and comparison operations</h3>
<p>Element-wise binary and unary operations.</p>
<ul>
<li>Arithmetics: +, -, *, /, <a class="el" href="group__core__hal__intrin.html#ga8bb510213a964865860cccf6b1ee42bb">v_mul_expand</a></li>
<li>Non-saturating arithmetics: v_add_wrap, v_sub_wrap</li>
<li>Bitwise shifts: &lt;&lt;, &gt;&gt;, v_shl, v_shr</li>
<li>Bitwise logic: &amp;, |, ^, <a class="el" href="group__core__hal__intrin.html#ga98d6664ea4069a2011fa0e356be35ccf">~</a></li>
<li>Comparison: &gt;, &gt;=, &lt;, &lt;=, ==, !=</li>
<li>min/max: v_min, v_max</li>
</ul>
<h3>Reduce and mask</h3>
<p>Most of these operations return only one value.</p>
<ul>
<li>Reduce: v_reduce_min, v_reduce_max, <a class="el" href="group__core__hal__intrin.html#ga51066f94e5de1b7905996186d848b5dc">v_reduce_sum</a>, <a class="el" href="group__core__hal__intrin.html#ga278f608463cbdd4d4a45f965e23b9ae5">v_popcount</a></li>
<li>Mask: <a class="el" href="group__core__hal__intrin.html#ga191a888185e95f221c8203884e8d66ec">v_signmask</a>, <a class="el" href="group__core__hal__intrin.html#gad4a93a907f23a3e9028172d09b4822f8">v_check_all</a>, <a class="el" href="group__core__hal__intrin.html#ga03282d0b7c46861f1ecc7329a40634b3">v_check_any</a>, <a class="el" href="group__core__hal__intrin.html#ga97f089f6c4606ddba14792d97bbe1b0d">v_select</a></li>
</ul>
<h3>Other math</h3>
<ul>
<li>Some frequent operations: v_sqrt, <a class="el" href="group__core__hal__intrin.html#ga66050acf0d0658d510929813d8f5eb74">v_invsqrt</a>, <a class="el" href="group__core__hal__intrin.html#ga6635a6259cd89761ce4edb164ea2d2b9">v_magnitude</a>, <a class="el" href="group__core__hal__intrin.html#ga572251b49e39236de0454d5448f0cabe">v_sqr_magnitude</a></li>
<li>Absolute values: v_abs, <a class="el" href="group__core__hal__intrin.html#ga4c726b4b37f3e691d2528b4ee5ff3e9b">v_absdiff</a>, <a class="el" href="group__core__hal__intrin.html#gab20066cd2de62b8691bee711ee4e76f9">v_absdiffs</a></li>
</ul>
<h3>Conversions</h3>
<p>Different type conversions and casts:</p>
<ul>
<li>Rounding: <a class="el" href="group__core__hal__intrin.html#ga08a1619cc35c793cf4e985bf814aa7b3">v_round</a>, <a class="el" href="group__core__hal__intrin.html#ga40660ffb65da4ec0ffcb13d3a8568e71">v_floor</a>, <a class="el" href="group__core__hal__intrin.html#ga2ae26ec587729aa1e9d548a1abc0e4d1">v_ceil</a>, <a class="el" href="group__core__hal__intrin.html#ga572e0c84eceb69db61eeee0a189b4cad">v_trunc</a>,</li>
<li>To float: <a class="el" href="group__core__hal__intrin.html#gad2782cdc9394130b4ebe3d62ff6964c7">v_cvt_f32</a>, <a class="el" href="group__core__hal__intrin.html#gaf3a9fce8f3c4ec707f44580f568ae7ae">v_cvt_f64</a></li>
<li>Reinterpret: v_reinterpret_as_u8, v_reinterpret_as_s8, ...</li>
</ul>
<h3>Matrix operations</h3>
<p>In these operations vectors represent matrix rows/columns: <a class="el" href="group__core__hal__intrin.html#ga46f313bb7694a20c902c1da740640a86">v_dotprod</a>, <a class="el" href="group__core__hal__intrin.html#ga4f53754058cbcd76b98db8525cefe869">v_matmul</a>, <a class="el" href="group__core__hal__intrin.html#gaf8bdcd643d22a9fc9c3f0ed202535928">v_transpose4x4</a></p>
<h3>Usability</h3>
<p>Most operations are implemented only for some subset of the available types, following matrices shows the applicability of different operations to the types.</p>
<p>Regular integers:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operations\Types  </th><th class="markdownTableHeadCenter">uint 8x16  </th><th class="markdownTableHeadCenter">int 8x16  </th><th class="markdownTableHeadCenter">uint 16x8  </th><th class="markdownTableHeadCenter">int 16x8  </th><th class="markdownTableHeadCenter">uint 32x4  </th><th class="markdownTableHeadCenter">int 32x4   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">load, store  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">interleave  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">expand  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">expand_low  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">expand_high  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">expand_q  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">add, sub  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">add_wrap, sub_wrap  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">mul_wrap  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">mul  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">mul_expand  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">compare  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">shift  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dotprod  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">logical  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">min, max  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">absdiff  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">absdiffs  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">reduce  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">mask  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">pack  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">pack_u  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">pack_b  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">unpack  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">extract  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">rotate (lanes)  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cvt_flt32  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cvt_flt64  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">transpose4x4  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
</table>
<p>Big integers:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operations\Types  </th><th class="markdownTableHeadCenter">uint 64x2  </th><th class="markdownTableHeadCenter">int 64x2   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">load, store  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">add, sub  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">shift  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">logical  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">extract  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">rotate (lanes)  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
</table>
<p>Floating point:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operations\Types  </th><th class="markdownTableHeadCenter">float 32x4  </th><th class="markdownTableHeadCenter">float 64x2   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">load, store  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">interleave  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">add, sub  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">mul  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">div  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">compare  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">min, max  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">absdiff  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">reduce  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">mask  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">unpack  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cvt_flt32  </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cvt_flt64  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">sqrt, abs  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">float math  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">transpose4x4  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">extract  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">rotate (lanes)  </td><td class="markdownTableBodyCenter">x  </td><td class="markdownTableBodyCenter">x   </td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga2323457942fdb195a2b1b6aac3bad605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2323457942fdb195a2b1b6aac3bad605">&#9670;&nbsp;</a></span>OPENCV_HAL_IMPL_ROTATE_SHIFT_OP <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OPENCV_HAL_IMPL_ROTATE_SHIFT_OP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">suffix, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opA, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opB&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise shift left. </p>
<p>For 16-, 32- and 64-bit integer values. Bitwise shift right</p>
<p>For 16-, 32- and 64-bit integer values. Element shift left among vector</p>
<p>For all type </p>

</div>
</div>
<a id="ga2323457942fdb195a2b1b6aac3bad605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2323457942fdb195a2b1b6aac3bad605">&#9670;&nbsp;</a></span>OPENCV_HAL_IMPL_ROTATE_SHIFT_OP <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OPENCV_HAL_IMPL_ROTATE_SHIFT_OP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">suffix, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opA, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opB&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise shift left. </p>
<p>For 16-, 32- and 64-bit integer values. Bitwise shift right</p>
<p>For 16-, 32- and 64-bit integer values. Element shift left among vector</p>
<p>For all type </p>

</div>
</div>
<a id="ga2323457942fdb195a2b1b6aac3bad605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2323457942fdb195a2b1b6aac3bad605">&#9670;&nbsp;</a></span>OPENCV_HAL_IMPL_ROTATE_SHIFT_OP <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OPENCV_HAL_IMPL_ROTATE_SHIFT_OP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">suffix, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opA, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opB&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise shift left. </p>
<p>For 16-, 32- and 64-bit integer values. Bitwise shift right</p>
<p>For 16-, 32- and 64-bit integer values. Element shift left among vector</p>
<p>For all type </p>

</div>
</div>
<a id="ga2323457942fdb195a2b1b6aac3bad605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2323457942fdb195a2b1b6aac3bad605">&#9670;&nbsp;</a></span>OPENCV_HAL_IMPL_ROTATE_SHIFT_OP <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OPENCV_HAL_IMPL_ROTATE_SHIFT_OP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">suffix, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opA, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opB&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise shift left. </p>
<p>For 16-, 32- and 64-bit integer values. Bitwise shift right</p>
<p>For 16-, 32- and 64-bit integer values. Element shift left among vector</p>
<p>For all type </p>

</div>
</div>
<a id="ga2323457942fdb195a2b1b6aac3bad605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2323457942fdb195a2b1b6aac3bad605">&#9670;&nbsp;</a></span>OPENCV_HAL_IMPL_ROTATE_SHIFT_OP <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OPENCV_HAL_IMPL_ROTATE_SHIFT_OP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">suffix, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opA, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opB&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise shift left. </p>
<p>For 16-, 32- and 64-bit integer values. Bitwise shift right</p>
<p>For 16-, 32- and 64-bit integer values. Element shift left among vector</p>
<p>For all type </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga98d6664ea4069a2011fa0e356be35ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98d6664ea4069a2011fa0e356be35ccf">&#9670;&nbsp;</a></span>operator ~()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; cv::operator ~ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise AND. </p>
<p>Only for integer types. Bitwise OR</p>
<p>Only for integer types. Bitwise XOR</p>
<p>Only for integer types. Bitwise NOT</p>
<p>Only for integer types. </p>

</div>
</div>
<a id="ga4c726b4b37f3e691d2528b4ee5ff3e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c726b4b37f3e691d2528b4ee5ff3e9b">&#9670;&nbsp;</a></span>v_absdiff() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::abs_type, n &gt; cv::v_absdiff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add values without saturation. </p>
<p>For 8- and 16-bit integer values. Subtract values without saturation</p>
<p>For 8- and 16-bit integer values. Multiply values without saturation</p>
<p>For 8- and 16-bit integer values. Absolute difference</p>
<p>Returns <img class="formulaInl" alt="$ |a - b| $" src="form_172.png"/> converted to corresponding unsigned type. Example: </p><div class="fragment"><div class="line"><a class="code" href="group__core__hal__intrin.html#ga0def4a347f9132829a6adffae8b002c5">v_int32x4</a> a, b; <span class="comment">// {1, 2, 3, 4} and {4, 3, 2, 1}</span></div><div class="line"><a class="code" href="group__core__hal__intrin.html#ga4c925ce71d458526b167f7710c9804f1">v_uint32x4</a> c = <a class="code" href="group__core__hal__intrin.html#ga4c726b4b37f3e691d2528b4ee5ff3e9b">v_absdiff</a>(a, b); <span class="comment">// result is {3, 1, 1, 3}</span></div></div><!-- fragment --><p> For 8-, 16-, 32-bit integer source types. </p>

</div>
</div>
<a id="ga1767714db3dcadb809e7186824764796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1767714db3dcadb809e7186824764796">&#9670;&nbsp;</a></span>v_absdiff() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> cv::v_absdiff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>For 32-bit floating point values </p>

</div>
</div>
<a id="gaedcb5a63b95a345d4da1d278b4617547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedcb5a63b95a345d4da1d278b4617547">&#9670;&nbsp;</a></span>v_absdiff() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__hal__intrin.html#gae5b879279ff9e297e12e0e0045f7cdb6">v_float64x2</a> cv::v_absdiff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gae5b879279ff9e297e12e0e0045f7cdb6">v_float64x2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gae5b879279ff9e297e12e0e0045f7cdb6">v_float64x2</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>For 64-bit floating point values </p>

</div>
</div>
<a id="gab20066cd2de62b8691bee711ee4e76f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab20066cd2de62b8691bee711ee4e76f9">&#9670;&nbsp;</a></span>v_absdiffs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; cv::v_absdiffs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saturating absolute difference. </p>
<p>Returns <img class="formulaInl" alt="$ saturate(|a - b|) $" src="form_173.png"/> . For 8-, 16-bit signed integer source types. </p>

</div>
</div>
<a id="ga2ae26ec587729aa1e9d548a1abc0e4d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ae26ec587729aa1e9d548a1abc0e4d1">&#9670;&nbsp;</a></span>v_ceil() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n &gt; cv::v_ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ceil. </p>
<p>Ceil each value. Input type is float vector ==&gt; output type is int vector. </p>

</div>
</div>
<a id="ga11eb63b0bee6d4da54ccf2654fd1617a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11eb63b0bee6d4da54ccf2654fd1617a">&#9670;&nbsp;</a></span>v_ceil() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n *2 &gt; cv::v_ceil </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gad4a93a907f23a3e9028172d09b4822f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4a93a907f23a3e9028172d09b4822f8">&#9670;&nbsp;</a></span>v_check_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cv::v_check_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if all packed values are less than zero. </p>
<p>Unsigned values will be casted to signed: <code>uchar 254 =&gt; char -2</code>. For all types except 64-bit. </p>

</div>
</div>
<a id="ga03282d0b7c46861f1ecc7329a40634b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03282d0b7c46861f1ecc7329a40634b3">&#9670;&nbsp;</a></span>v_check_any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cv::v_check_any </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if any of packed values is less than zero. </p>
<p>Unsigned values will be casted to signed: <code>uchar 254 =&gt; char -2</code>. For all types except 64-bit. </p>

</div>
</div>
<a id="ga07992fc8a3a9af17eb8fc4460b6e178e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07992fc8a3a9af17eb8fc4460b6e178e">&#9670;&nbsp;</a></span>v_combine_high()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; cv::v_combine_high </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine vector from last elements of two vectors. </p>
<p>Scheme: </p><div class="fragment"><div class="line">  {A1 A2 A3 A4}</div><div class="line">  {B1 B2 B3 B4}</div><div class="line">---------------</div><div class="line">  {A3 A4 B3 B4}</div></div><!-- fragment --><p> For all types except 64-bit. </p>

</div>
</div>
<a id="gad083778ca6d5d290b698a963eef18863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad083778ca6d5d290b698a963eef18863">&#9670;&nbsp;</a></span>v_combine_low()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; cv::v_combine_low </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine vector from first elements of two vectors. </p>
<p>Scheme: </p><div class="fragment"><div class="line">  {A1 A2 A3 A4}</div><div class="line">  {B1 B2 B3 B4}</div><div class="line">---------------</div><div class="line">  {A1 A2 B1 B2}</div></div><!-- fragment --><p> For all types except 64-bit. </p>

</div>
</div>
<a id="gad2782cdc9394130b4ebe3d62ff6964c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2782cdc9394130b4ebe3d62ff6964c7">&#9670;&nbsp;</a></span>v_cvt_f32()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt; cv::v_cvt_f32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to float. </p>
<p>Supported input type is <a class="el" href="group__core__hal__intrin.html#ga0def4a347f9132829a6adffae8b002c5" title="Four 32-bit signed integer values.">cv::v_int32x4</a>. </p>

</div>
</div>
<a id="gaf3a9fce8f3c4ec707f44580f568ae7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3a9fce8f3c4ec707f44580f568ae7ae">&#9670;&nbsp;</a></span>v_cvt_f64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; cv::v_cvt_f64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n *2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to double. </p>
<p>Supported input type is <a class="el" href="group__core__hal__intrin.html#ga0def4a347f9132829a6adffae8b002c5" title="Four 32-bit signed integer values.">cv::v_int32x4</a>. </p>

</div>
</div>
<a id="ga05e90423771387353c348a19def2edb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05e90423771387353c348a19def2edb5">&#9670;&nbsp;</a></span>v_cvt_f64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; cv::v_cvt_f64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n *2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert to double. </p>
<p>Supported input type is <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b" title="Four 32-bit floating point values (single precision)">cv::v_float32x4</a>. </p>

</div>
</div>
<a id="ga46f313bb7694a20c902c1da740640a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46f313bb7694a20c902c1da740640a86">&#9670;&nbsp;</a></span>v_dotprod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::w_type, n/2 &gt; cv::v_dotprod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dot product of elements. </p>
<p>Multiply values in two registers and sum adjacent result pairs. Scheme: </p><div class="fragment"><div class="line">  {A1 A2 ...} <span class="comment">// 16-bit</span></div><div class="line">x {B1 B2 ...} <span class="comment">// 16-bit</span></div><div class="line">-------------</div><div class="line">{A1B1+A2B2 ...} <span class="comment">// 32-bit</span></div></div><!-- fragment --><p> Implemented only for 16-bit signed source type (v_int16x8). </p>

</div>
</div>
<a id="ga29aab83572d06b4f0ecfd8aace22233d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29aab83572d06b4f0ecfd8aace22233d">&#9670;&nbsp;</a></span>v_dotprod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::w_type, n/2 &gt; cv::v_dotprod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::w_type, n/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dot product of elements. </p>
<p>Same as <a class="el" href="group__core__hal__intrin.html#ga46f313bb7694a20c902c1da740640a86" title="Dot product of elements.">cv::v_dotprod</a>, but add a third element to the sum of adjacent pairs. Scheme: </p><div class="fragment"><div class="line">  {A1 A2 ...} <span class="comment">// 16-bit</span></div><div class="line">x {B1 B2 ...} <span class="comment">// 16-bit</span></div><div class="line">-------------</div><div class="line">  {A1B1+A2B2+C1 ...} <span class="comment">// 32-bit</span></div></div><!-- fragment --><p> Implemented only for 16-bit signed source type (v_int16x8). </p>

</div>
</div>
<a id="ga9eff16d8d73c6ce81122b3cd44a99627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9eff16d8d73c6ce81122b3cd44a99627">&#9670;&nbsp;</a></span>v_expand()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_expand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::w_type, n/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::w_type, n/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand values to the wider pack type. </p>
<p>Copy contents of register to two registers with 2x wider pack type. Scheme: </p><div class="fragment"><div class="line"> int32x4     int64x2 int64x2</div><div class="line">{A B C D} ==&gt; {A B} , {C D}</div></div><!-- fragment --> 
</div>
</div>
<a id="gab499a3329ea0f6735a7c0da9258943fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab499a3329ea0f6735a7c0da9258943fd">&#9670;&nbsp;</a></span>v_expand_high()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::w_type, n/2 &gt; cv::v_expand_high </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand higher values to the wider pack type. </p>
<p>Same as <a class="el" href="group__core__hal__intrin.html#ga9bee20edc309cbb268408083754e1e14" title="Expand lower values to the wider pack type.">cv::v_expand_low</a>, but expand higher half of the vector instead.</p>
<p>Scheme: </p><div class="fragment"><div class="line"> int32x4     int64x2</div><div class="line">{A B C D} ==&gt; {C D}</div></div><!-- fragment --> 
</div>
</div>
<a id="ga9bee20edc309cbb268408083754e1e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bee20edc309cbb268408083754e1e14">&#9670;&nbsp;</a></span>v_expand_low()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::w_type, n/2 &gt; cv::v_expand_low </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand lower values to the wider pack type. </p>
<p>Same as <a class="el" href="group__core__hal__intrin.html#ga9eff16d8d73c6ce81122b3cd44a99627" title="Expand values to the wider pack type.">cv::v_expand</a>, but return lower half of the vector.</p>
<p>Scheme: </p><div class="fragment"><div class="line"> int32x4     int64x2</div><div class="line">{A B C D} ==&gt; {A B}</div></div><!-- fragment --> 
</div>
</div>
<a id="gafd8010dbc3fd9f58d0bcc78b09bb04be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd8010dbc3fd9f58d0bcc78b09bb04be">&#9670;&nbsp;</a></span>v_extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int s, typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; cv::v_extract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector extract. </p>
<p>Scheme: </p><div class="fragment"><div class="line">  {A1 A2 A3 A4}</div><div class="line">  {B1 B2 B3 B4}</div><div class="line">========================</div><div class="line">shift = 1  {A2 A3 A4 B1}</div><div class="line">shift = 2  {A3 A4 B1 B2}</div><div class="line">shift = 3  {A4 B1 B2 B3}</div></div><!-- fragment --><p> Restriction: 0 &lt;= shift &lt; nlanes</p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code" href="group__core__hal__intrin.html#ga0def4a347f9132829a6adffae8b002c5">v_int32x4</a> a, b, c;</div><div class="line">c = v_extract&lt;2&gt;(a, b);</div></div><!-- fragment --><p> For all types. </p>

</div>
</div>
<a id="ga40660ffb65da4ec0ffcb13d3a8568e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40660ffb65da4ec0ffcb13d3a8568e71">&#9670;&nbsp;</a></span>v_floor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n &gt; cv::v_floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Floor. </p>
<p>Floor each value. Input type is float vector ==&gt; output type is int vector. </p>

</div>
</div>
<a id="ga5c2b8152bc9dfee7f4ed37b4a35c45e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c2b8152bc9dfee7f4ed37b4a35c45e6">&#9670;&nbsp;</a></span>v_floor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n *2 &gt; cv::v_floor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gaa5aa4bc7f178b3cc0e6b11781003dd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5aa4bc7f178b3cc0e6b11781003dd77">&#9670;&nbsp;</a></span>v_fma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; cv::v_fma </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and add. </p>
<p>Returns <img class="formulaInl" alt="$ a*b + c $" src="form_177.png"/> For floating point types and signed 32bit int only. </p>

</div>
</div>
<a id="ga66050acf0d0658d510929813d8f5eb74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66050acf0d0658d510929813d8f5eb74">&#9670;&nbsp;</a></span>v_invsqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; cv::v_invsqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inversed square root. </p>
<p>Returns <img class="formulaInl" alt="$ 1/sqrt(a) $" src="form_174.png"/> For floating point types only. </p>

</div>
</div>
<a id="ga418ca8678c1cc9fe07a14d13a4de2c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga418ca8678c1cc9fe07a14d13a4de2c56">&#9670;&nbsp;</a></span>v_load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::nlanes128 &gt; cv::v_load </td>
          <td>(</td>
          <td class="paramtype">const _Tp *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load register contents from memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>pointer to memory block with data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>register object</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returned type will be detected from passed pointer type, for example uchar ==&gt; <a class="el" href="group__core__hal__intrin.html#gaa3a568f303a60e9ee0db873bfaf92015" title="Sixteen 8-bit unsigned integer values.">cv::v_uint8x16</a>, int ==&gt; <a class="el" href="group__core__hal__intrin.html#ga0def4a347f9132829a6adffae8b002c5" title="Four 32-bit signed integer values.">cv::v_int32x4</a>, etc. </dd></dl>

</div>
</div>
<a id="gaa798b76235e5d37e9bdff10e403052a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa798b76235e5d37e9bdff10e403052a5">&#9670;&nbsp;</a></span>v_load_aligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::nlanes128 &gt; cv::v_load_aligned </td>
          <td>(</td>
          <td class="paramtype">const _Tp *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load register contents from memory (aligned) </p>
<p>similar to <a class="el" href="group__core__hal__intrin.html#ga418ca8678c1cc9fe07a14d13a4de2c56" title="Load register contents from memory.">cv::v_load</a>, but source memory block should be aligned (to 16-byte boundary) </p>

</div>
</div>
<a id="gafd8e859406c66bb5b7d901473265119b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd8e859406c66bb5b7d901473265119b">&#9670;&nbsp;</a></span>v_load_deinterleave() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_load_deinterleave </td>
          <td>(</td>
          <td class="paramtype">const _Tp *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and deinterleave (2 channels) </p>
<p>Load data from memory deinterleave and store to 2 registers. Scheme: </p><div class="fragment"><div class="line">{A1 B1 A2 B2 ...} ==&gt; {A1 A2 ...}, {B1 B2 ...}</div></div><!-- fragment --><p> For all types except 64-bit. </p>

</div>
</div>
<a id="gab364b341969494d47e6a1b173fc46658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab364b341969494d47e6a1b173fc46658">&#9670;&nbsp;</a></span>v_load_deinterleave() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_load_deinterleave </td>
          <td>(</td>
          <td class="paramtype">const _Tp *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and deinterleave (3 channels) </p>
<p>Load data from memory deinterleave and store to 3 registers. Scheme: </p><div class="fragment"><div class="line">{A1 B1 C1 A2 B2 C2 ...} ==&gt; {A1 A2 ...}, {B1 B2 ...}, {C1 C2 ...}</div></div><!-- fragment --><p> For all types except 64-bit. </p>

</div>
</div>
<a id="ga7f1f0d87d6210547bb125fd349a10e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f1f0d87d6210547bb125fd349a10e5d">&#9670;&nbsp;</a></span>v_load_deinterleave() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_load_deinterleave </td>
          <td>(</td>
          <td class="paramtype">const _Tp *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and deinterleave (4 channels) </p>
<p>Load data from memory deinterleave and store to 4 registers. Scheme: </p><div class="fragment"><div class="line">{A1 B1 C1 D1 A2 B2 C2 D2 ...} ==&gt; {A1 A2 ...}, {B1 B2 ...}, {C1 C2 ...}, {D1 D2 ...}</div></div><!-- fragment --><p> For all types except 64-bit. </p>

</div>
</div>
<a id="gaf31e8453b851d1017dd3736bb18e5031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf31e8453b851d1017dd3736bb18e5031">&#9670;&nbsp;</a></span>v_load_expand()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::w_type, <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::nlanes128/2 &gt; cv::v_load_expand </td>
          <td>(</td>
          <td class="paramtype">const _Tp *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load register contents from memory with double expand. </p>
<p>Same as <a class="el" href="group__core__hal__intrin.html#ga418ca8678c1cc9fe07a14d13a4de2c56" title="Load register contents from memory.">cv::v_load</a>, but result pack type will be 2x wider than memory type.</p>
<div class="fragment"><div class="line"><span class="keywordtype">short</span> buf[4] = {1, 2, 3, 4}; <span class="comment">// type is int16</span></div><div class="line"><a class="code" href="group__core__hal__intrin.html#ga0def4a347f9132829a6adffae8b002c5">v_int32x4</a> r = <a class="code" href="group__core__hal__intrin.html#gaf31e8453b851d1017dd3736bb18e5031">v_load_expand</a>(buf); <span class="comment">// r = {1, 2, 3, 4} - type is int32</span></div></div><!-- fragment --><p> For 8-, 16-, 32-bit integer source types. </p>

</div>
</div>
<a id="gae3505ff70e83d0809045ef1dcd91f927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3505ff70e83d0809045ef1dcd91f927">&#9670;&nbsp;</a></span>v_load_expand_q()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::q_type, <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::nlanes128/4 &gt; cv::v_load_expand_q </td>
          <td>(</td>
          <td class="paramtype">const _Tp *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load register contents from memory with quad expand. </p>
<p>Same as <a class="el" href="group__core__hal__intrin.html#gaf31e8453b851d1017dd3736bb18e5031" title="Load register contents from memory with double expand.">cv::v_load_expand</a>, but result type is 4 times wider than source. </p><div class="fragment"><div class="line"><span class="keywordtype">char</span> buf[4] = {1, 2, 3, 4}; <span class="comment">// type is int8</span></div><div class="line"><a class="code" href="group__core__hal__intrin.html#ga0def4a347f9132829a6adffae8b002c5">v_int32x4</a> r = v_load_q(buf); <span class="comment">// r = {1, 2, 3, 4} - type is int32</span></div></div><!-- fragment --><p> For 8-bit integer source types. </p>

</div>
</div>
<a id="ga4b3dbadf9e2c2f5b1bb4827200bc5912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b3dbadf9e2c2f5b1bb4827200bc5912">&#9670;&nbsp;</a></span>v_load_halves()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::nlanes128 &gt; cv::v_load_halves </td>
          <td>(</td>
          <td class="paramtype">const _Tp *&#160;</td>
          <td class="paramname"><em>loptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp *&#160;</td>
          <td class="paramname"><em>hiptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load register contents from two memory blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loptr</td><td>memory block containing data for first half (0..n/2) </td></tr>
    <tr><td class="paramname">hiptr</td><td>memory block containing data for second half (n/2..n)</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> lo[2] = { 1, 2 }, hi[2] = { 3, 4 };</div><div class="line"><a class="code" href="group__core__hal__intrin.html#ga0def4a347f9132829a6adffae8b002c5">v_int32x4</a> r = <a class="code" href="group__core__hal__intrin.html#ga4b3dbadf9e2c2f5b1bb4827200bc5912">v_load_halves</a>(lo, hi);</div></div><!-- fragment --> 
</div>
</div>
<a id="gad8311a12f1fff9a41c84092a8f8afe4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8311a12f1fff9a41c84092a8f8afe4c">&#9670;&nbsp;</a></span>v_load_low()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::nlanes128 &gt; cv::v_load_low </td>
          <td>(</td>
          <td class="paramtype">const _Tp *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load 64-bits of data to lower part (high part is undefined). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>memory block containing data for first half (0..n/2)</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> lo[2] = { 1, 2 };</div><div class="line"><a class="code" href="group__core__hal__intrin.html#ga0def4a347f9132829a6adffae8b002c5">v_int32x4</a> r = <a class="code" href="group__core__hal__intrin.html#gad8311a12f1fff9a41c84092a8f8afe4c">v_load_low</a>(lo);</div></div><!-- fragment --> 
</div>
</div>
<a id="ga6635a6259cd89761ce4edb164ea2d2b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6635a6259cd89761ce4edb164ea2d2b9">&#9670;&nbsp;</a></span>v_magnitude()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; cv::v_magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Magnitude. </p>
<p>Returns <img class="formulaInl" alt="$ sqrt(a^2 + b^2) $" src="form_175.png"/> For floating point types only. </p>

</div>
</div>
<a id="ga4f53754058cbcd76b98db8525cefe869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f53754058cbcd76b98db8525cefe869">&#9670;&nbsp;</a></span>v_matmul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> cv::v_matmul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>m0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>m3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix multiplication. </p>
<p>Scheme: </p><div class="fragment"><div class="line">{A0 A1 A2 A3}   |V0|</div><div class="line">{B0 B1 B2 B3}   |V1|</div><div class="line">{C0 C1 C2 C3}   |V2|</div><div class="line">{D0 D1 D2 D3} x |V3|</div><div class="line">====================</div><div class="line">{R0 R1 R2 R3}, where:</div><div class="line">R0 = A0V0 + A1V1 + A2V2 + A3V3,</div><div class="line">R1 = B0V0 + B1V1 + B2V2 + B3V3</div><div class="line">...</div></div><!-- fragment --> 
</div>
</div>
<a id="ga1a36df5c9313f6132192c0b9ae2aefb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a36df5c9313f6132192c0b9ae2aefb0">&#9670;&nbsp;</a></span>v_matmuladd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> cv::v_matmuladd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>m0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>m3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix multiplication and add. </p>
<p>Scheme: </p><div class="fragment"><div class="line">{A0 A1 A2   }   |V0|   |D0|</div><div class="line">{B0 B1 B2   }   |V1|   |D1|</div><div class="line">{C0 C1 C2   } x |V2| + |D2|</div><div class="line">====================</div><div class="line">{R0 R1 R2 R3}, where:</div><div class="line">R0 = A0V0 + A1V1 + A2V2 + D0,</div><div class="line">R1 = B0V0 + B1V1 + B2V2 + D1</div><div class="line">...</div></div><!-- fragment --> 
</div>
</div>
<a id="ga8bb510213a964865860cccf6b1ee42bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bb510213a964865860cccf6b1ee42bb">&#9670;&nbsp;</a></span>v_mul_expand()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_mul_expand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::w_type, n/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::w_type, n/2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and expand. </p>
<p>Multiply values two registers and store results in two registers with wider pack type. Scheme: </p><div class="fragment"><div class="line">  {A B C D} <span class="comment">// 32-bit</span></div><div class="line">x {E F G H} <span class="comment">// 32-bit</span></div><div class="line">---------------</div><div class="line">{AE BF}         <span class="comment">// 64-bit</span></div><div class="line">        {CG DH} <span class="comment">// 64-bit</span></div></div><!-- fragment --><p> Example: </p><div class="fragment"><div class="line"><a class="code" href="group__core__hal__intrin.html#ga4c925ce71d458526b167f7710c9804f1">v_uint32x4</a> a, b; <span class="comment">// {1,2,3,4} and {2,2,2,2}</span></div><div class="line"><a class="code" href="group__core__hal__intrin.html#ga90f59b07f91cd87c17fdc439a6d96b09">v_uint64x2</a> c, d; <span class="comment">// results</span></div><div class="line"><a class="code" href="group__core__hal__intrin.html#ga8bb510213a964865860cccf6b1ee42bb">v_mul_expand</a>(a, b, c, d); <span class="comment">// c, d = {2,4}, {6, 8}</span></div></div><!-- fragment --><p> Implemented only for 16- and unsigned 32-bit source types (v_int16x8, v_uint16x8, v_uint32x4). </p>

</div>
</div>
<a id="gac0f63284358630a4670facb86b5e9534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0f63284358630a4670facb86b5e9534">&#9670;&nbsp;</a></span>v_mul_hi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; cv::v_mul_hi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply and extract high part. </p>
<p>Multiply values two registers and store high part of the results. Implemented only for 16-bit source types (v_int16x8, v_uint16x8). Returns <img class="formulaInl" alt="$ a*b &gt;&gt; 16 $" src="form_178.png"/> </p>

</div>
</div>
<a id="gae43382fae6719e75b63ecb19726f6b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae43382fae6719e75b63ecb19726f6b84">&#9670;&nbsp;</a></span>v_not_nan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt; cv::v_not_nan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Less-than comparison. </p>
<p>For all types except 64-bit integer values. Greater-than comparison</p>
<p>For all types except 64-bit integer values. Less-than or equal comparison</p>
<p>For all types except 64-bit integer values. Greater-than or equal comparison</p>
<p>For all types except 64-bit integer values. Equal comparison</p>
<p>For all types except 64-bit integer values. Not equal comparison</p>
<p>For all types except 64-bit integer values. </p>

</div>
</div>
<a id="ga4183265b6f133d0a8a8b6598cfa61fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4183265b6f133d0a8a8b6598cfa61fe8">&#9670;&nbsp;</a></span>v_pack_b() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__hal__intrin.html#gaa3a568f303a60e9ee0db873bfaf92015">v_uint8x16</a> cv::v_pack_b </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#ga966d320e20d694dfd6ca21c2175d25d7">v_uint16x8</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#ga966d320e20d694dfd6ca21c2175d25d7">v_uint16x8</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>! For 16-bit boolean values </p>
<p>Scheme: </p><div class="fragment"><div class="line">a  {0xFFFF 0 0 0xFFFF 0 0xFFFF 0xFFFF 0}</div><div class="line">b  {0xFFFF 0 0xFFFF 0 0 0xFFFF 0 0xFFFF}</div><div class="line">===============</div><div class="line">{</div><div class="line">   0xFF 0 0 0xFF 0 0xFF 0xFF 0</div><div class="line">   0xFF 0 0xFF 0 0 0xFF 0 0xFF</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="gad7e6ed6c7c6d0cf64f295fd8b86c08f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7e6ed6c7c6d0cf64f295fd8b86c08f8">&#9670;&nbsp;</a></span>v_pack_b() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__hal__intrin.html#gaa3a568f303a60e9ee0db873bfaf92015">v_uint8x16</a> cv::v_pack_b </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#ga4c925ce71d458526b167f7710c9804f1">v_uint32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#ga4c925ce71d458526b167f7710c9804f1">v_uint32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#ga4c925ce71d458526b167f7710c9804f1">v_uint32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#ga4c925ce71d458526b167f7710c9804f1">v_uint32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. For 32-bit boolean values</p>
<p>Scheme: </p><div class="fragment"><div class="line">a  {0xFFFF.. 0 0 0xFFFF..}</div><div class="line">b  {0 0xFFFF.. 0xFFFF.. 0}</div><div class="line">c  {0xFFFF.. 0 0xFFFF.. 0}</div><div class="line">d  {0 0xFFFF.. 0 0xFFFF..}</div><div class="line">===============</div><div class="line">{</div><div class="line">   0xFF 0 0 0xFF 0 0xFF 0xFF 0</div><div class="line">   0xFF 0 0xFF 0 0 0xFF 0 0xFF</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="gad4f237e5e9fd54dfef2590bb4ee686a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4f237e5e9fd54dfef2590bb4ee686a2">&#9670;&nbsp;</a></span>v_pack_b() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__hal__intrin.html#gaa3a568f303a60e9ee0db873bfaf92015">v_uint8x16</a> cv::v_pack_b </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#ga90f59b07f91cd87c17fdc439a6d96b09">v_uint64x2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#ga90f59b07f91cd87c17fdc439a6d96b09">v_uint64x2</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#ga90f59b07f91cd87c17fdc439a6d96b09">v_uint64x2</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#ga90f59b07f91cd87c17fdc439a6d96b09">v_uint64x2</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#ga90f59b07f91cd87c17fdc439a6d96b09">v_uint64x2</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#ga90f59b07f91cd87c17fdc439a6d96b09">v_uint64x2</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#ga90f59b07f91cd87c17fdc439a6d96b09">v_uint64x2</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#ga90f59b07f91cd87c17fdc439a6d96b09">v_uint64x2</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. For 64-bit boolean values</p>
<p>Scheme: </p><div class="fragment"><div class="line">a  {0xFFFF.. 0}</div><div class="line">b  {0 0xFFFF..}</div><div class="line">c  {0xFFFF.. 0}</div><div class="line">d  {0 0xFFFF..}</div><div class="line"></div><div class="line">e  {0xFFFF.. 0}</div><div class="line">f  {0xFFFF.. 0}</div><div class="line">g  {0 0xFFFF..}</div><div class="line">h  {0 0xFFFF..}</div><div class="line">===============</div><div class="line">{</div><div class="line">   0xFF 0 0 0xFF 0xFF 0 0 0xFF</div><div class="line">   0xFF 0 0xFF 0 0 0xFF 0 0xFF</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="ga278f608463cbdd4d4a45f965e23b9ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga278f608463cbdd4d4a45f965e23b9ae5">&#9670;&nbsp;</a></span>v_popcount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__hal__intrin.html#ga4c925ce71d458526b167f7710c9804f1">v_uint32x4</a> cv::v_popcount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the 1 bits in the vector and return 4 values. </p>
<p>Scheme: </p><div class="fragment"><div class="line">{A1 A2 A3 ...} =&gt; popcount(A1)</div></div><!-- fragment --><p> Any types but result will be in v_uint32x4 </p>

</div>
</div>
<a id="ga75a3cb5bb426fc37d9ed2f10e8706997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75a3cb5bb426fc37d9ed2f10e8706997">&#9670;&nbsp;</a></span>v_recombine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_recombine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine two vectors from lower and higher parts of two other vectors. </p>
<div class="fragment"><div class="line">low = <a class="code" href="group__core__hal__intrin.html#gad083778ca6d5d290b698a963eef18863">cv::v_combine_low</a>(a, b);</div><div class="line">high = <a class="code" href="group__core__hal__intrin.html#ga07992fc8a3a9af17eb8fc4460b6e178e">cv::v_combine_high</a>(a, b);</div></div><!-- fragment --> 
</div>
</div>
<a id="ga40a6183aa6144610007fd188a2188039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40a6183aa6144610007fd188a2188039">&#9670;&nbsp;</a></span>v_reduce_sad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; typename <a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::abs_type &gt;::sum_type cv::v_reduce_sad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum absolute differences of values. </p>
<p>Scheme: </p><div class="fragment"><div class="line">{A1 A2 A3 ...} {B1 B2 B3 ...} =&gt; sum{ABS(A1-B1),<a class="code" href="group__core__utils__softfloat.html#ga72dd776aec140cd56401b29af17e36c3">abs</a>(A2-B2),<a class="code" href="group__core__utils__softfloat.html#ga72dd776aec140cd56401b29af17e36c3">abs</a>(A3-B3),...}</div></div><!-- fragment --><p> For all types except 64-bit types. </p>

</div>
</div>
<a id="ga51066f94e5de1b7905996186d848b5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51066f94e5de1b7905996186d848b5dc">&#9670;&nbsp;</a></span>v_reduce_sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1_v___type_traits.html">V_TypeTraits</a>&lt; _Tp &gt;::sum_type cv::v_reduce_sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum packed values. </p>
<p>Scheme: </p><div class="fragment"><div class="line">{A1 A2 A3 ...} =&gt; sum{A1,A2,A3,...}</div></div><!-- fragment --><p> For 32-bit integer and 32-bit floating point types. </p>

</div>
</div>
<a id="gafec4c6d20a68eba604ec1a480f457f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafec4c6d20a68eba604ec1a480f457f34">&#9670;&nbsp;</a></span>v_reduce_sum4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> cv::v_reduce_sum4 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__hal__intrin.html#gaddfab95c46aa6df24bc5ef3947bd311b">v_float32x4</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sums all elements of each input vector, returns the vector of sums. </p>
<p>Scheme: </p><div class="fragment"><div class="line">result[0] = a[0] + a[1] + a[2] + a[3]</div><div class="line">result[1] = b[0] + b[1] + b[2] + b[3]</div><div class="line">result[2] = c[0] + c[1] + c[2] + c[3]</div><div class="line">result[3] = d[0] + d[1] + d[2] + d[3]</div></div><!-- fragment --> 
</div>
</div>
<a id="ga08a1619cc35c793cf4e985bf814aa7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08a1619cc35c793cf4e985bf814aa7b3">&#9670;&nbsp;</a></span>v_round() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n &gt; cv::v_round </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round. </p>
<p>Rounds each value. Input type is float vector ==&gt; output type is int vector. </p>

</div>
</div>
<a id="gab76c02016dd0346ae33faf583f0c231b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab76c02016dd0346ae33faf583f0c231b">&#9670;&nbsp;</a></span>v_round() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n *2 &gt; cv::v_round </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga50363564443765f12ecce74cf6cab1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50363564443765f12ecce74cf6cab1f8">&#9670;&nbsp;</a></span>v_round() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n *2 &gt; cv::v_round </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga97f089f6c4606ddba14792d97bbe1b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97f089f6c4606ddba14792d97bbe1b0d">&#9670;&nbsp;</a></span>v_select()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; cv::v_select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Per-element select (blend operation) </p>
<p>Return value will be built by combining values <em>a</em> and <em>b</em> using the following scheme: result[i] = mask[i] ? a[i] : b[i];</p>
<dl class="section note"><dt>Note</dt><dd>: <em>mask</em> element values are restricted to these values:<ul>
<li>0: select element from <em>b</em></li>
<li>0xff/0xffff/etc: select element from <em>a</em> (fully compatible with bitwise-based operator) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga191a888185e95f221c8203884e8d66ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga191a888185e95f221c8203884e8d66ec">&#9670;&nbsp;</a></span>v_signmask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int cv::v_signmask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get negative values mask. </p>
<p>Returned value is a bit mask with bits set to 1 on places corresponding to negative packed values indexes. Example: </p><div class="fragment"><div class="line"><a class="code" href="group__core__hal__intrin.html#ga0def4a347f9132829a6adffae8b002c5">v_int32x4</a> r; <span class="comment">// set to {-1, -1, 1, 1}</span></div><div class="line"><span class="keywordtype">int</span> mask = <a class="code" href="group__core__hal__intrin.html#ga191a888185e95f221c8203884e8d66ec">v_signmask</a>(r); <span class="comment">// mask = 3 &lt;== 00000000 00000000 00000000 00000011</span></div></div><!-- fragment --><p> For all types except 64-bit. </p>

</div>
</div>
<a id="ga572251b49e39236de0454d5448f0cabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga572251b49e39236de0454d5448f0cabe">&#9670;&nbsp;</a></span>v_sqr_magnitude()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; cv::v_sqr_magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Square of the magnitude. </p>
<p>Returns <img class="formulaInl" alt="$ a^2 + b^2 $" src="form_176.png"/> For floating point types only. </p>

</div>
</div>
<a id="ga275dfa9c8935f5e9a1031121cde460f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga275dfa9c8935f5e9a1031121cde460f4">&#9670;&nbsp;</a></span>v_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_store </td>
          <td>(</td>
          <td class="paramtype">_Tp *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store data to memory. </p>
<p>Store register contents to memory. Scheme: </p><div class="fragment"><div class="line">REG {A B C D} ==&gt; MEM {A B C D}</div></div><!-- fragment --><p> Pointer can be unaligned. </p>

</div>
</div>
<a id="gaf2733377e1bc373657d0e203028c74fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2733377e1bc373657d0e203028c74fc">&#9670;&nbsp;</a></span>v_store_aligned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_store_aligned </td>
          <td>(</td>
          <td class="paramtype">_Tp *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store data to memory (aligned) </p>
<p>Store register contents to memory. Scheme: </p><div class="fragment"><div class="line">REG {A B C D} ==&gt; MEM {A B C D}</div></div><!-- fragment --><p> Pointer <b>should</b> be aligned by 16-byte boundary. </p>

</div>
</div>
<a id="ga1665beb52f3824499d3b6b1203890ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1665beb52f3824499d3b6b1203890ada">&#9670;&nbsp;</a></span>v_store_high()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_store_high </td>
          <td>(</td>
          <td class="paramtype">_Tp *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store data to memory (higher half) </p>
<p>Store higher half of register contents to memory. Scheme: </p><div class="fragment"><div class="line">REG {A B C D} ==&gt; MEM {C D}</div></div><!-- fragment --> 
</div>
</div>
<a id="gaa809d0656c94b2bb24b9be06295f037e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa809d0656c94b2bb24b9be06295f037e">&#9670;&nbsp;</a></span>v_store_interleave() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_store_interleave </td>
          <td>(</td>
          <td class="paramtype">_Tp *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hal::StoreMode&#160;</td>
          <td class="paramname"> = <code>hal::STORE_UNALIGNED</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleave and store (2 channels) </p>
<p>Interleave and store data from 2 registers to memory. Scheme: </p><div class="fragment"><div class="line">{A1 A2 ...}, {B1 B2 ...} ==&gt; {A1 B1 A2 B2 ...}</div></div><!-- fragment --><p> For all types except 64-bit. </p>

</div>
</div>
<a id="ga642197a56fa99a60b9caeee19fed1a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga642197a56fa99a60b9caeee19fed1a61">&#9670;&nbsp;</a></span>v_store_interleave() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_store_interleave </td>
          <td>(</td>
          <td class="paramtype">_Tp *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hal::StoreMode&#160;</td>
          <td class="paramname"> = <code>hal::STORE_UNALIGNED</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleave and store (3 channels) </p>
<p>Interleave and store data from 3 registers to memory. Scheme: </p><div class="fragment"><div class="line">{A1 A2 ...}, {B1 B2 ...}, {C1 C2 ...} ==&gt; {A1 B1 C1 A2 B2 C2 ...}</div></div><!-- fragment --><p> For all types except 64-bit. </p>

</div>
</div>
<a id="ga7f28a67e567d9f1fee7a16d264fcaa5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f28a67e567d9f1fee7a16d264fcaa5d">&#9670;&nbsp;</a></span>v_store_interleave() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_store_interleave </td>
          <td>(</td>
          <td class="paramtype">_Tp *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hal::StoreMode&#160;</td>
          <td class="paramname"> = <code>hal::STORE_UNALIGNED</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleave and store (4 channels) </p>
<p>Interleave and store data from 4 registers to memory. Scheme: </p><div class="fragment"><div class="line">{A1 A2 ...}, {B1 B2 ...}, {C1 C2 ...}, {D1 D2 ...} ==&gt; {A1 B1 C1 D1 A2 B2 C2 D2 ...}</div></div><!-- fragment --><p> For all types except 64-bit. </p>

</div>
</div>
<a id="ga3cb662d09e37eae1e73043badee69612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cb662d09e37eae1e73043badee69612">&#9670;&nbsp;</a></span>v_store_low()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_store_low </td>
          <td>(</td>
          <td class="paramtype">_Tp *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store data to memory (lower half) </p>
<p>Store lower half of register contents to memory. Scheme: </p><div class="fragment"><div class="line">REG {A B C D} ==&gt; MEM {A B}</div></div><!-- fragment --> 
</div>
</div>
<a id="gaf8bdcd643d22a9fc9c3f0ed202535928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8bdcd643d22a9fc9c3f0ed202535928">&#9670;&nbsp;</a></span>v_transpose4x4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_transpose4x4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transpose 4x4 matrix. </p>
<p>Scheme: </p><div class="fragment"><div class="line">a0  {A1 A2 A3 A4}</div><div class="line">a1  {B1 B2 B3 B4}</div><div class="line">a2  {C1 C2 C3 C4}</div><div class="line">a3  {D1 D2 D3 D4}</div><div class="line">===============</div><div class="line">b0  {A1 B1 C1 D1}</div><div class="line">b1  {A2 B2 C2 D2}</div><div class="line">b2  {A3 B3 C3 D3}</div><div class="line">b3  {A4 B4 C4 D4}</div></div><!-- fragment --> 
</div>
</div>
<a id="ga572e0c84eceb69db61eeee0a189b4cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga572e0c84eceb69db61eeee0a189b4cad">&#9670;&nbsp;</a></span>v_trunc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n &gt; cv::v_trunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; float, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trunc. </p>
<p>Truncate each value. Input type is float vector ==&gt; output type is int vector. </p>

</div>
</div>
<a id="ga5eb1af43eca988202b5374a5486cfd09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5eb1af43eca988202b5374a5486cfd09">&#9670;&nbsp;</a></span>v_trunc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; int, n *2 &gt; cv::v_trunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; double, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga19ef6326f6c132d75c62391cedf7c187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19ef6326f6c132d75c62391cedf7c187">&#9670;&nbsp;</a></span>v_zip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cv::v_zip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcv_1_1v__reg.html">v_reg</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>b1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleave two vectors. </p>
<p>Scheme: </p><div class="fragment"><div class="line">  {A1 A2 A3 A4}</div><div class="line">  {B1 B2 B3 B4}</div><div class="line">---------------</div><div class="line">  {A1 B1 A2 B2} and {A3 B3 A4 B4}</div></div><!-- fragment --><p> For all types except 64-bit. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
